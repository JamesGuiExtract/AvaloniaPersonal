// CategoryManager.cpp : Implementation of CCategoryManager
#include "stdafx.h"
#include "UCLIDCOMUtils.h"
#include "CategoryManager.h"

#include <ComCat.h>
#include <ComDef.h>
#include <LicenseMgmt.h>
#include <UCLIDException.h>
#include <COMUtils.h>
#include <CommentedTextFileReader.h>
#include <StringTokenizer.h>
#include <cpputil.h>
#include <ComponentLicenseIDs.h>

#include <io.h>
#include <fstream>
#include <vector>
using namespace std;

//-------------------------------------------------------------------------------------------------
// Constants
//-------------------------------------------------------------------------------------------------
const char gcCACHE_FILE_DELIMITER = ';';
const string gstrCACHE_FILE_SIGNATURE = "*** DO NOT EDIT THIS FILE *** UCLID Category Manager Cache File ***";

//-------------------------------------------------------------------------------------------------
// ISupportsErrorInfo
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICategoryManager,
		&IID_ILicensedComponent
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//-------------------------------------------------------------------------------------------------
// ICategoryManager
//-------------------------------------------------------------------------------------------------
CCategoryManager::CCategoryManager()
	: m_strCacheFileRoot("")
{
}
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::GetCategoryNames(BSTR strPrefix, IVariantVector **pCategoryNames)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try
	{
		// validate license and enable the wait cursor as this method
		// make take some time to execute
		validateLicense();
		CWaitCursor waitCursor;

		// create an instance of the Category Information manager
		CComQIPtr<ICatInformation> ptrCatInfo;
		ptrCatInfo.CoCreateInstance(CLSID_StdComponentCategoriesMgr, 0,
			CLSCTX_INPROC_SERVER);
		
		// get all the available categories
		CComQIPtr<IEnumCATEGORYINFO> ptrEnumCatInfo;
		HRESULT hr = ptrCatInfo->EnumCategories(0x409, &ptrEnumCatInfo);
		if (FAILED(hr))
			return S_FALSE;
		
		// create a variant collection object to store the result
		UCLID_COMUTILSLib::IVariantVectorPtr ipVarCollection;
		ipVarCollection.CreateInstance(__uuidof(VariantVector));
		
		// iterate through all the available categories and find matches
		CATEGORYINFO catInfo;
		ULONG numFetched = 0;
		while (SUCCEEDED(ptrEnumCatInfo->Next(1, &catInfo, &numFetched))) 
		{
			if (numFetched == 0)
				break;
			
			_bstr_t _bstrCurrCategoryName = catInfo.szDescription;
			string stdstrCurrCategoryName = _bstrCurrCategoryName;
			string stdstrPrefix = asString( strPrefix );
			
			if (stdstrCurrCategoryName != "" && (stdstrPrefix == "" || 
				stdstrCurrCategoryName.find(stdstrPrefix) == 0))
			{
				ipVarCollection->PushBack(_bstrCurrCategoryName);
			}
		}
		
		CComQIPtr<IVariantVector> ipRet(ipVarCollection);
		*pCategoryNames = ipRet.Detach();
	}
	CATCH_ALL_AND_RETURN_AS_COM_ERROR("ELI03118");

	return S_OK;
}
//-------------------------------------------------------------------------------------------------
string CCategoryManager::getCacheFileName(const string& strCategoryName)
{
	string strCacheFileName = getCacheFileRoot() + strCategoryName + ".lst";
	return strCacheFileName;
}
//-------------------------------------------------------------------------------------------------
string CCategoryManager::getCacheFileRoot()
{
	if (m_strCacheFileRoot == "")
	{
		m_strCacheFileRoot = getExtractApplicationDataPath() + "\\CategoryFiles";

		// Ensure the directory exists
		if (!isValidFolder(m_strCacheFileRoot))
		{
			createDirectory(m_strCacheFileRoot);
		}

		m_strCacheFileRoot += "\\";
	}

	return m_strCacheFileRoot;
}
//-------------------------------------------------------------------------------------------------
void CCategoryManager::verifyComponentDescription(const string& strDescription)
{
	if (strDescription.find_first_of(gcCACHE_FILE_DELIMITER) != string::npos)
	{
		UCLIDException ue("ELI04338", "Invalid UCLID Component description!");
		ue.addDebugInfo("Description", strDescription);
		throw ue;
	}
}
//-------------------------------------------------------------------------------------------------
void CCategoryManager::createCacheFile(BSTR bstrCategoryName,
									   const string& strFileName)
{
	// create the cache file
	string stdstrCategoryName = asString( bstrCategoryName );
	ofstream cacheFile(strFileName.c_str());
	if (!cacheFile)
	{
		UCLIDException ue("ELI04266", "Unable to open cache file in write mode!");
		ue.addDebugInfo("Filename", strFileName);
		ue.addDebugInfo("Category", stdstrCategoryName);
		throw ue;
	}

	// write the signature line to the cache file
	cacheFile << gstrCACHE_FILE_SIGNATURE << endl;

	// get all components under the specified category
	vector<string> vecComponentProgIDs = 
		::getComponentProgIDsInCategory(stdstrCategoryName);
	int iNumComponents = vecComponentProgIDs.size();
	
	// iterate through each of the components and write description/progID to 
	// cache file
	for (int i = 0; i < iNumComponents; i++)
	{
		string strDescription;
		
		try
		{
			try
			{		 
				UCLID_COMUTILSLib::ICategorizedComponentPtr ipComponent(vecComponentProgIDs[i].c_str());
				if (ipComponent == __nullptr)
				{
					UCLIDException ue("ELI18366",
						"Application Trace: Component has no category information.");
					throw ue;
				}

				// Check licensing before adding components to cache.  Components are allowable
				// if they either do not implement ILicensedComponent or if
				// ILicensedComponent::IsLicensed returns VARIANT_TRUE
				ILicensedComponentPtr ipLic(ipComponent);
				if (ipLic != __nullptr &&
					ipLic->IsLicensed() == VARIANT_FALSE)
				{
					// Component is not licensed; do not add it to the cache.
					continue;
				}
				
				// get the component description
				strDescription = asString(ipComponent->GetComponentDescription());
			}
			CATCH_ALL_AND_RETHROW_AS_UCLID_EXCEPTION("ELI18365");
		}
		catch(UCLIDException &ue)
		{
			ue.addDebugInfo("Component category", asString(bstrCategoryName));
			ue.addDebugInfo("Component Prog ID", vecComponentProgIDs[i].c_str());
			ue.log();
			continue;
		}

		try
		{
			verifyComponentDescription(strDescription);
		}
		catch (UCLIDException& ue)
		{
			ue.addDebugInfo("ProgID", vecComponentProgIDs[i].c_str());
			throw ue;
		}

		// write the component description and prog id to the cache file
		cacheFile << strDescription << gcCACHE_FILE_DELIMITER << vecComponentProgIDs[i] << endl;
	} 

	// Close the file and wait for it to be readable
	cacheFile.close();
	waitForFileToBeReadable(strFileName);
}
//-------------------------------------------------------------------------------------------------
void CCategoryManager::verifyCategoryName(const string& strCategoryName)
{
	// since we are using the category name as the cache file name,
	// make sure that the category name only contains characters that
	// are valid for a filename.  The category name can't also contain
	// the delimiting character used in the cache file.
	const string strINVALID_FILE_NAME_CHARS = "\\/:*?\"<>|";
	string strInvalidCategoryNameChars = strINVALID_FILE_NAME_CHARS;
	strInvalidCategoryNameChars += gcCACHE_FILE_DELIMITER;
	if (strCategoryName.find_first_of(strInvalidCategoryNameChars) != 
		string::npos)
	{
		UCLIDException ue("ELI04325", "Invalid UCLID Component Category name!");
		ue.addDebugInfo("CategoryName", strCategoryName);
		ue.addDebugInfo("Invalid chars list", strInvalidCategoryNameChars);
		throw ue;
	}
}
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::GetDescriptionToProgIDMap1(BSTR strCategoryName, 
														 IStrToStrMap **pMap)
{
	return GetDescriptionToProgIDMap2(strCategoryName, 0, NULL, pMap);
}
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::GetDescriptionToProgIDMap2(BSTR strCategoryName, 
														 long nNumIIDs, 
														 IID pIIDs[],
														 IStrToStrMap **pMap)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try
	{
		// validate license and enable the wait cursor as this method
		// make take some time to execute
		validateLicense();
		CWaitCursor waitCursor;

		// verify that the category name does not contain invalid chars
		string stdstrCategoryName = asString( strCategoryName );
		verifyCategoryName(stdstrCategoryName);

		// compute the cache file name for the specified category name
		// if the cache file does not exist, then re-create the cache file
		string strCacheFileName = getCacheFileName(stdstrCategoryName);
		
		if (!isValidFile(strCacheFileName))
		{
			createCacheFile(strCategoryName, strCacheFileName);
		}

		// create the return map object
		UCLID_COMUTILSLib::IStrToStrMapPtr ipDescriptionToProgIDMap(CLSID_StrToStrMap);
		
		if (ipDescriptionToProgIDMap == __nullptr)
		{
			throw UCLIDException("ELI04262", "Unable to create StrToStrMap object!");
		}

		// open the cache file for reading
		ifstream ifs(strCacheFileName.c_str());
		CommentedTextFileReader fileReader(ifs, "//", true);

		// read the first line of the cache file and ensure that the signature
		// is valid
		string strFirstLineText(fileReader.getLineText());
		
		if (strFirstLineText != gstrCACHE_FILE_SIGNATURE)
		{
			UCLIDException ue("ELI04270", "Invalid Category Manager cache file!");
			ue.addDebugInfo("Filename", strCacheFileName);
			ue.addDebugInfo("Category", stdstrCategoryName);
			ue.addDebugInfo("Line1", strFirstLineText);
			throw ue;
		}

		// Read each line in the file and populate the map
		do
		{
			// read a line from the file.  If the line is empty, we're done
			string strLineText(fileReader.getLineText());
			
			if (strLineText.empty())
			{
				break;
			}

			// parse the line and split into exactly two parts
			vector<string> vecTokens;
			StringTokenizer tokenizer(gcCACHE_FILE_DELIMITER, false);
			tokenizer.parse(strLineText.c_str(), vecTokens);
			
			if (vecTokens.size() != 2)
			{
				UCLIDException ue("ELI04264", "Internal error: incorrect format of Categorized Components cache file!");
				ue.addDebugInfo("Category", stdstrCategoryName);
				ue.addDebugInfo("Cache file", strCacheFileName);
				ue.addDebugInfo("Line text", strLineText);
				throw ue;
			}

			// we found exactly two entries. add entry to the map if the component
			// meets the required-interfaces constraint
			if (componentImplementsRequiredInteraces(vecTokens[1], nNumIIDs, pIIDs))
			{
				ipDescriptionToProgIDMap->Set(_bstr_t(vecTokens[0].c_str()),
					_bstr_t(vecTokens[1].c_str()));
			}

		} 
		while (true);

		// return the map to the caller
		CComQIPtr<IStrToStrMap> ipMap(ipDescriptionToProgIDMap);
		*pMap = ipMap.Detach();
	}
	CATCH_ALL_AND_RETURN_AS_COM_ERROR("ELI04263")

	return S_OK;
}
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::DeleteCache(BSTR strCategoryName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try
	{
		// compute the cache file name for the specified category name
		string stdstrCategoryName = asString( strCategoryName );
		string strCacheFileName = getCacheFileName(stdstrCategoryName);

		// if the cache file exists, delete it
		if (isValidFile(strCacheFileName))
		{
			try
			{
				deleteFile(strCacheFileName, true);
			}
			catch(UCLIDException& uex)
			{
				uex.addDebugInfo("Category", stdstrCategoryName);
				throw uex;
			}
		}
	}
	CATCH_ALL_AND_RETURN_AS_COM_ERROR("ELI04272")

	return S_OK;
}
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::CheckForNewComponents(IVariantVector *pCategoryNames)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try
	{
		UCLID_COMUTILSLib::IVariantVectorPtr ipCategoryNames(pCategoryNames);
		ASSERT_ARGUMENT("ELI18164", ipCategoryNames != __nullptr);

		int nCount = ipCategoryNames->Size;

		for (int i = 0; i < nCount; i++)
		{
			// delete the cache file for the current category
			getThisAsCOMPtr()->DeleteCache(ipCategoryNames->Item[i].bstrVal);

			// recreate the cache file for the category
			getThisAsCOMPtr()->GetDescriptionToProgIDMap1(ipCategoryNames->Item[i].bstrVal);
		}
	}
	CATCH_ALL_AND_RETURN_AS_COM_ERROR("ELI18160")

	return S_OK;
}

//-------------------------------------------------------------------------------------------------
// ILicensedComponent
//-------------------------------------------------------------------------------------------------
STDMETHODIMP CCategoryManager::raw_IsLicensed(VARIANT_BOOL * pbValue)
{
	try
	{
		validateLicense();
		// if validateLicense doesn't throw any exception, then pbValue is true
		*pbValue = VARIANT_TRUE;
	}
	catch(...)
	{
		*pbValue = VARIANT_FALSE;
	}

	return S_OK;
}

//-------------------------------------------------------------------------------------------------
// Helper functions
//-------------------------------------------------------------------------------------------------
bool CCategoryManager::componentImplementsRequiredInteraces(const string& strProgID,
															long nNumIIDs,
															IID pIIDs[])
{
	// ensure that the array has some elements in it
	if (nNumIIDs < 0)
	{
		UCLIDException ue("ELI04589", "Invalid number of array entries!");
		ue.addDebugInfo("nNumIIDs", nNumIIDs);
		throw ue;
	}
	else if (nNumIIDs == 0)
	{
		// nothing to check - just return true
		return true;
	}

	// create the component
	IUnknownPtr ipUnknown(strProgID.c_str());
	if (ipUnknown == __nullptr)
	{
		UCLIDException ue("ELI04588", "Unable to create component!");
		ue.addDebugInfo("ProgID", strProgID);
		throw ue;
	}

	// verify that the component implments each of the specified
	// categories
	for (int j = 0; j < nNumIIDs; j++)
	{
		// do a QI for the interface
		IUnknownPtr ipTemp;
		ipUnknown.QueryInterface(pIIDs[j], &ipTemp);
		
		// if the QI fails - return false
		if (ipTemp == __nullptr)
		{
			return false;
		}
	}

	// we were able to do a QI for all the required interfaces - so return true
	return true;
}
//-------------------------------------------------------------------------------------------------
void CCategoryManager::validateLicense()
{
	static const unsigned long CATEGORY_MANAGER_COMPONENT_ID = gnEXTRACT_CORE_OBJECTS;

	VALIDATE_LICENSE( CATEGORY_MANAGER_COMPONENT_ID, "ELI03114",
		"Category Manager" );
}
//-------------------------------------------------------------------------------------------------
UCLID_COMUTILSLib::ICategoryManagerPtr CCategoryManager::getThisAsCOMPtr()
{
	UCLID_COMUTILSLib::ICategoryManagerPtr ipThis(this);
	ASSERT_RESOURCE_ALLOCATION("ELI18161", ipThis != __nullptr);

	return ipThis;
}
//-------------------------------------------------------------------------------------------------