// UCLIDFileProcessing.idl : IDL source for UCLIDFileProcessing.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (UCLIDFileProcessing.tlb) and marshaling code.

import "oaidl.idl";
import "ocidl.idl";
midl_pragma warning(disable:2362)

[
	uuid(5FBC9199-D162-4F14-BAD9-090F6AB576C5),
	version(1.0),
	helpstring("UCLID FileProcessing 1.0 Type Library")
]
library UCLID_FILEPROCESSINGLib
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");
	importlib("..\..\UCLIDComponentsLM\COMLM\Code\COMLM.tlb");
	importlib("..\..\UCLIDCOMUtils\Core\Code\UCLIDCOMUtils.tlb");
	importlib("Common Files\System\ADO\msado28.tlb");
	importlib("..\..\..\..\RC.Net\Interfaces\Core\Code\Extract.Interfaces.tlb");
	
	/////////////////////////
	// forward declarations
	/////////////////////////
	interface IFileSupplierTarget;
	interface IFileProcessingDB;
	interface IFileSupplierData;
	interface IFileSupplyingMgmtRole;	
	interface IFileProcessingMgmtRole;
	interface IFAMTagManager;
	interface IRoleNotifyFAM;
	interface ISetProcessingSchedule;
	interface IFileRecord;
	interface IParallelizableTask;
	interface IWorkItemRecord;
	interface IFileRequestHandler;
	interface IFAMFileSelector;

	//----------------------------------------------------------------------------------------------
	//-E N U M S -----------------------------------------------------------------------------------
	//----------------------------------------------------------------------------------------------
	typedef
		[
			uuid(E5280058-AFE9-41a3-8A4A-5CF92957441E), 
			helpstring("UCLID EScopeType")
		]
	enum EScopeType
	{
		kNoScope = 0,
		kFolderScope = 1,
		kIndividualFilesScope = 2
	}EScopeType;

	typedef
		[
			uuid(D9A40A2C-0EBC-4f38-BB77-435621F17618), 
			helpstring("UCLID EFilterPatternType")
		]
	enum EFilterPatternType
	{
		kNoFilter = 0,
		kFilterWithRegExp = 1
	}EFilterPatternType;

	typedef
		[
			uuid(2398267B-C2AC-4681-BB61-9675EB3154C4), 
			helpstring("UCLID EFilterType")
		]
	enum EFilterType
	{
		kContain = 0,
		kDoesNotContain = 1

	}EFilterType;

	typedef
		[
			uuid(666CDCA3-BDB0-4005-87AF-070FAFEB1CAC), 
			helpstring("Extract EActionStatus")
		]
	enum EActionStatus
	{
		kActionUnattempted = 0,
		kActionPending = 1,
		kActionProcessing = 2,
		kActionCompleted = 3,
		kActionFailed = 4,
		kActionSkipped = 5
	}EActionStatus;

	typedef
		[
			uuid(4AE21420-B07C-4447-87FE-AEAA3E5B4843), 
			helpstring("Extract EFileSupplierStatus")
		]
	enum EFileSupplierStatus
	{
		kInactiveStatus = 0,
		kActiveStatus = 1,
		kPausedStatus = 2,
		kStoppedStatus = 3,
		kDoneStatus = 4
	}EFileSupplierStatus;

	typedef
		[
			uuid(FADBF221-FD67-4260-B5D3-A350F961942F),
			helpstring("Extract EFileProcessingResult")
		]
	enum EFileProcessingResult
	{
		kProcessingSuccessful = 0,
		kProcessingCancelled = 1,
		kProcessingSkipped = 2,
		kProcessingDelayed = 3
	}EFileProcessingResult;

	// EFilePriority definition.
	// NOTE: If modifying priorities in this enum, also need to update
	//		 the IFileProcessingDB::GetPriorities method to return the
	//		 appropriate strings in the appropriate order.
	typedef
		[
			uuid(8BEC1731-CD1A-4931-809D-C53FDF9BA21F),
			helpstring("Extract EFilePriority")
		]
	enum EFilePriority
	{
		kPriorityDefault = 0,
		kPriorityLow = 1,
		kPriorityBelowNormal = 2,
		kPriorityNormal = 3,
		kPriorityAboveNormal = 4,
		kPriorityHigh = 5
	}EFilePriority;

	typedef
		[
			uuid(A1838015-95E3-4E83-8325-69A3F26B25E1), 
			helpstring("Extract FTPAction")
		]
	enum EFTPAction
	{
		kUploadFileToFtpServer = 0,
		kDownloadFileFromFtpServer = 1,
		kDeleteFileFromFtpServer = 2,
		kRenameFileOnFtpServer = 3,
		kGetDirectoryListing = 4
	}EFTPAction;

	typedef
		[
			uuid(67549CC0-38D5-45BE-83BE-39B40FDD2E6A),
			helpstring("Extract EWorkItemStatus")
		]
	enum EWorkItemStatus
	{
		kWorkUnitPending = 0,
		kWorkUnitProcessing = 1,
		kWorkUnitComplete = 2,
		kWorkUnitFailed = 3
	} EWorkItemStatus;

	typedef
		[
			uuid("3AC5BFA0-CE9C-4C58-92FE-78806086539E"),
			helpstring("WorkItemGroup status structure.")
		]
	struct WorkItemGroupStatus
	{
		[helpstring("Work Group ID")] long WorkGroupID;
		[helpstring("Pending count for group")] long lPendingCount;
		[helpstring("Processing count for group")] long lProcessingCount;
		[helpstring("Failed count for group")] long lFailedCount;
		[helpstring("Completed count for group")] long lCompletedCount;
		[helpstring("Total work items")] long lTotal;
	} WorkItemGroupStatus;

	typedef
		[
			uuid(46849A2C-C3B2-4A61-8577-531E7C4CA933),
			helpstring("Workflow types")
		]
	enum EWorkflowType
	{
		kUndefined = 0,
		kRedaction = 1,
		kExtraction = 2,
		kClassification = 3
	} EWorkflowType;

	//----------------------------------------------------------------------------------------------
	//-I N T E R F A C E S -------------------------------------------------------------------------
	//----------------------------------------------------------------------------------------------
	[
		object,
		uuid(E46D8A95-EA9B-4D90-8703-99621B19E4A0),
		dual,
		helpstring("IMathConditionChecker Interface"),
		pointer_default(unique)
	]
	interface IMathConditionChecker : IDispatch
	{
		// Returns VARIANT_TRUE if the condition is met and VARIANT_FALSE if it is not met
		[id(10001), helpstring("method CheckCondition")] HRESULT CheckCondition(
			[in] IFileRecord* pFileRecord, [in] long lActionID, 
			[out, retval] VARIANT_BOOL* pbResult);
	};

	[
		object,
		uuid(30409BCC-76AF-4C72-940E-7C2E71604B0C),
		dual,
		helpstring("IRandomMathCondition Interface"),
		pointer_default(unique)
	]
	interface IRandomMathCondition : IMathConditionChecker
	{
		// Percentage of when the condition is satisfied (must be between 1 and 99 inclusive)
		[propget, id(1), helpstring("property Percent")] HRESULT Percent([out, retval] long* pnPercent);
		[propput, id(1), helpstring("property Percent")] HRESULT Percent([in] long nPercent);
	};

	[
		object,
		uuid(5B2A7A6D-665F-41FB-B591-EC3C9902E26E),
		dual,
		helpstring("IOnceEveryMathCondition Interface"),
		pointer_default(unique)
	]
	interface IOnceEveryMathCondition : IMathConditionChecker
	{
		// How often each run the condition is satisfied (must be greater than 2)
		[propget, id(1), helpstring("property NumberOfTimes")] HRESULT NumberOfTimes(
			[out, retval] long* pnTimes);
		[propput, id(1), helpstring("property NumberOfTimes")] HRESULT NumberOfTimes(
			[in] long nTimes);

		// A unique ID for this instance of the condition checker. It is recommended
		// that the caller use a GUID generator to assign this value.
		[propget, id(2), helpstring("property UsageID")] HRESULT UsageID(
			[out, retval] BSTR* bstrUsageID);
		[propput, id(2), helpstring("property UsageID")] HRESULT UsageID(
			[in] BSTR bstrUsageID);
	};

	[
		object,
		uuid(70C82D6D-69BF-4D4F-83BB-C406FCAB28F1),
		dual,
		helpstring("IModulusEqualsMathCondition Interface"),
		pointer_default(unique)
	]
	interface IModulusEqualsMathCondition : IMathConditionChecker
	{
		// The modulus value for checking the condition. Must be > 1.
		[propget, id(1), helpstring("property Modulus")] HRESULT Modulus([out, retval] long* pnModulus);
		[propput, id(1), helpstring("property Modulus")] HRESULT Modulus([in] long nModulus);

		// The value that the modulus must equal for the condition to be satisfied
		// Must be >= 0 and < Modulus.
		[propget, id(2), helpstring("property ModEquals")] HRESULT ModEquals(
			[out, retval] long* pnValue);
		[propput, id(2), helpstring("property ModEquals")] HRESULT ModEquals([in] long nValue);
	};

	[
		object,
		uuid(FE7DED54-C988-43f4-A80B-60DA54F5904B),
		dual,
		helpstring("IFileProcessingTask Interface"),
		pointer_default(unique)
	]
	// IFileProcessingTask Note:
	// Multiple instances may be created in different threads and acted upon at the time
	// If the task cannot be run multithreaded, the task is required to control processing 
	// via mutexes as necessary to make it thread-safe. Currently there is only one case
	// where this is an issue: the RedactionVerificationUI.
	interface IFileProcessingTask : IAccessRequired
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		To alert the file processor that processing is about to start so it can 
		//				perform any necessary initialization.
		// ARGUMENTS:	nActionID - The ID of the action being processed
		//				pFAMTM - A FAMTagManager object for expanding filename tags/methods
		//				pDB - The database being operated upon
		//				pFileRequestHandler- The IFileRequestHandler that can be used
        //				by the task to carry out requests for files to be checked out, released or
		//				re-ordered in the queue.
		// NOTE:		This may be called multiple times on the same object because the same coClass
		//				may be being used in multiple threads.  This will happen per processing session
		//				not per file.
		//				See note about IFileProcessingTask multithreading above
		[id(11), helpstring("method Init")] HRESULT Init([in] long nActionID,
			[in] IFAMTagManager* pFAMTM, [in] IFileProcessingDB* pDB,
			[in] IFileRequestHandler* pFileRequestHandler);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		To process the file strFileFullName and output a vector of files either generated
		//				or the file being processed. 
		// REQUIRED:	Must handle value of strFileFullName with a value of "" as an indication that
		//				there are no more files to process. If the implementation requires data to be
		//				cleared that data should be reset and any generated output files should be 
		//				placed on the pFiles vector returned. If strFileFullName = "" then the pFiles 
		//				vector returned MUST contain any files to output with an empty string "" as the last entry in the vector.
		//				IF the strFileFullName was not "" an empty string "" should not be returned in the
		//				pFiles vector.
		// ARGUMENTS:	pFileRecord - The file record of the file to be processed
		//				pResult - If kProcessingSuccessful, file should be set to Completed,
		//					if kProcessingCancelled file should revert to pending; if kProcessingDelayed,
		//					the file should remain checked out for processing, but allow the next
		//					file to go ahead of it. If kProcessingSkipped, file should be set to skipped.
		//				nActionID - The ID of the action being processed
		//				pFAMTM - A FAMTagManager object for expanding filename tags/methods
		//				pDB - The database being operated upon
		//				pProgressStatus - A caller may pass in a progress status object 
		//					if the caller is interested in the progress information.  If the caller
		//					passes in a progress status object to this method, and if the CoClass 
		//					implementing this interface is capable of providing progress information,
		//					the CoClass will update the provided progress status object with
		//					progress information.  No CoClass is required to provide progress
		//					status information.  Those that do provide progress status information are
		//					free to update the progress status information at random times, or at 
		//					a particular frequency of the CoClass's choice.  A CoClass capable
		//					of providing progress information is also free to create one or more 
		//					sub-levels of progress information.
		//				bCancelRequested - VARIANT_TRUE if the user has requested cancellation.  Similar to
		//					the Cancel method (below), it is not required that the FileProcessingTask
		//					act upon this request. However, if the task is capable of honoring cancellation
		//					requests, it should respond to a value of VARIANT_TRUE by not starting processing
		//					and immediately returning VARIANT_FALSE
		//					NOTE: As of 07/20/2009, all non-UI tasks happen to be non-cancellable and all
		//					UI tasks happen to be cancellable.  As of now, only the UI tasks check the value of
		//					bCancelRequested.  Since the non-UI tasks are not cancellable (as of now), they
		//					don't check this flag, and as a result, we get a guarantee (for now) that if all tasks in
		//					the FPS file are non-cancellable tasks, we get a "run all tasks" or "run no tasks"
		//					guarantee for a particular SourceDocName, like a database transaction which is either 
		//					committed or rolled back.
		// NOTE:		See note about IFileProcessingTask multithreading above
		[id(12), helpstring("method ProcessFile")] HRESULT ProcessFile([in] IFileRecord* pFileRecord, 
			[in] long nActionID, [in] IFAMTagManager* pFAMTM, [in] IFileProcessingDB* pDB, 
			[in] IProgressStatus* pProgressStatus, [in] VARIANT_BOOL bCancelRequested, 
			[out, retval] EFileProcessingResult* pResult);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To allow the FileProcessingManager to request that this processor stop processing its current file
		//			if it is able
		// PROMISE: The FileProcessingManager makes this request to ask the Processor to stop at its earliest 
		//			convenience.  Nothing is required of the FileProcessor when this method is called.
		// NOTE:	This method will be called from a different thread than the one that called process file
		[id(13), helpstring("method Cancel")] HRESULT Cancel();
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		To notify a file processor that the processing has been completed.
		//				(allowing the file processor to perform any cleanup it may wish to do)
		// NOTE:		This may be called multiple times on the same object because the same coClass
		//				may be being used in multiple threads. This will happen per processing session
		//				not per file
		[id(14), helpstring("method Close")] HRESULT Close();
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		To notify a file processor that the pending document queue is empty, but
		//				the processing tasks have been configured to remain running until the next
		//				document has been supplied. If the processor will standby until the next
		//				file is supplied it should return VARIANT_TRUE. If the processor wants to
		//				cancel processing, it should return VARIANT_FALSE. If the processor does not
		//				immediately know whether processing should be cancelled right away, it may
		//				block until it does know, and return at that time.
		// NOTE:		This call will be made on a different thread than the other calls, so the
		//				Standby call must be thread-safe.This allows the file processor to block on
		//				the Standby call, but it also means that call to ProcessFile or Close may
		//				come while the Standby call is still occurring. If this happens, the return
		//				value of Standby will be ignored; however, Standby should promptly return
		//				in this case to avoid needlessly keeping a thread alive.
		[id(15), helpstring("method Standby")] HRESULT Standby([out, retval] VARIANT_BOOL* pVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		Specifies the minimum stack size needed for the thread in which this task
		//				is to be run. The stack size for each processing thread will be the max
		//				value of the Windows default stack size (1048576 or 1MB) and all the individual
		//				MinStackSize values of the processing tasks.
		[propget, id(16), helpstring("property MinStackSize")] HRESULT MinStackSize([out, retval] unsigned long* pnMinStackSize);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		Property that indicates that the task displays a UI
		[propget, id(17), helpstring("property DisplaysUI")] HRESULT DisplaysUI([out, retval] VARIANT_BOOL* pVal);
	};

	[
		object,
		uuid(28C8AA7B-5DFE-402E-891B-22B61C650F42),
		dual,
		helpstring("IFileProcessingManager Interface"),
		pointer_default(unique)
	]
	interface IFileProcessingManager : IDispatch
	{
		[id(9), helpstring("method ShowUI")] HRESULT ShowUI([in] VARIANT_BOOL bRunOnInit, [in] VARIANT_BOOL bCloseOnComplete, 
			VARIANT_BOOL bForceClose, int iNumDocsToExecute, void * pFRM);
		[id(10), helpstring("method StartProcessing")] HRESULT StartProcessing();
		[id(11), helpstring("method StopProcessing")] HRESULT StopProcessing();
		[id(17), helpstring("method LoadFrom")] HRESULT LoadFrom([in] BSTR strFullFileName, [in] VARIANT_BOOL bSetDirtyFlagToTrue);
		[id(18), helpstring("method SaveTo")] HRESULT SaveTo([in] BSTR strFullFileName, [in] VARIANT_BOOL bClearDirty);
		[propget, id(19), helpstring("property FPSFileName")] HRESULT FPSFileName([out, retval] BSTR* pVal);
		[propput, id(19), helpstring("property FPSFileName")] HRESULT FPSFileName([in] BSTR newVal);
		[propget, id(24), helpstring("property MaxStoredRecords")] HRESULT MaxStoredRecords([out, retval] long* pVal);
		[propput, id(24), helpstring("property MaxStoredRecords")] HRESULT MaxStoredRecords([in] long newVal);
		[propget, id(25), helpstring("property RestrictNumStoredRecords")] HRESULT RestrictNumStoredRecords([out, retval] VARIANT_BOOL* pVal);
		[propput, id(25), helpstring("property RestrictNumStoredRecords")] HRESULT RestrictNumStoredRecords([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To pause the threads that are currently processing files
		//			The pause will not take effect immediately.  Any files that have already 
		//			started processing will continue to be processed until processing is
		//			complete for that file.
		// NOTES:	To resume processing, invoke the StartProcessing method.
		[id(27), helpstring("method PauseProcessing")] HRESULT PauseProcessing();
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To return boolean flags indicating whether processing has started
		// PROMISE:	To return VARIANT_TRUE if processing was started with the StartProcessing()
		//			method, and if StopProcessing() has not yet been called since the last
		//			call to StartProcessing().
		// NOTES:	The return value of this method has no relevance to whether processing
		//			is currently paused.
		[propget, id(28), helpstring("property ProcessingStarted")] HRESULT ProcessingStarted([out, retval] VARIANT_BOOL* pbValue);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To return boolean flags indicating whether processing is currently paused
		// REQUIRE: ProcessingHasStarted() must return VARIANT_TRUE before this function can
		//			be called.
		// PROMISE:	To return VARIANT_TRUE if processing is in a paused state
		[propget, id(29), helpstring("property ProcessingPaused")] HRESULT ProcessingPaused([out, retval] VARIANT_BOOL* pbValue);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To load the IndividualFileList from a file
		[id(31), helpstring("method LoadFilesFromFile")] HRESULT LoadFilesFromFile([in] BSTR bstrFileName);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the name of the Action to process (May contain tags)
		[propget, id(34), helpstring("property ActionName")] HRESULT ActionName([out, retval] BSTR* pVal);
		[propput, id(34), helpstring("property ActionName")] HRESULT ActionName([in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set/return the status of the Display check box in action tab,
		//			indicating whether the statistics tab is displayed or not
		[propget, id(38), helpstring("property DisplayOfStatisticsEnabled")] HRESULT DisplayOfStatisticsEnabled([out, retval] VARIANT_BOOL* pVal);
		[propput, id(38), helpstring("property DisplayOfStatisticsEnabled")] HRESULT DisplayOfStatisticsEnabled([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To restore the FileProcessingManager to its default state, where there is no
		//			data (e.g. file suppliers, file processors, action, etc) associated with it.
		// PROMISE:	This method will clear out all member variables and set the object's state to
		//			that of a brand new instance of the FileProcessingManager
		[id(39), helpstring("method Clear")] HRESULT Clear();
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return com exception if it can not be saved or run
		[id(40), helpstring("method ValidateStatus")] HRESULT ValidateStatus(void);
		//-----------------------------------------------------------------------------------------
		[propget, id(41), helpstring("property FileSupplyingMgmtRole")] HRESULT FileSupplyingMgmtRole([out, retval] IFileSupplyingMgmtRole** pVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(42), helpstring("property FileProcessingMgmtRole")] HRESULT FileProcessingMgmtRole([out, retval] IFileProcessingMgmtRole** pVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the Action ID associated with the specified Action Name.
		// REQUIRE: Registry must contain a valid connection string 
		// PROMISE: To return the associated Action ID or 0 if not found
		[id(43), helpstring("method GetActionIDFromName")] HRESULT GetActionIDFromName([in] BSTR bstrActionName, 
			[out, retval] long* pVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set and get the name of the Database configuration file in the FAMDB object
		//[propput, id(44), helpstring("property DBConfigFileName")] HRESULT DBConfigFileName([in] BSTR newVal);		
		//[propget, id(44), helpstring("property DBConfigFileName")] HRESULT DBConfigFileName([out, retval] BSTR* pVal);		
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set and get the database server name
		// NOTE:	The value may be a path tag expression to be evaluated. 
		[propput, id(45), helpstring("property DatabaseServer")] HRESULT DatabaseServer([in] BSTR newVal);
		[propget, id(45), helpstring("property DatabaseServer")] HRESULT DatabaseServer([out, retval] BSTR* pVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set and get the database name
		// NOTE:	The value may be a path tag expression to be evaluated.
		[propput, id(46), helpstring("property DatabaseName")] HRESULT DatabaseName([in] BSTR newVal);		
		[propget, id(46), helpstring("property DatabaseName")] HRESULT DatabaseName([out, retval] BSTR* pVal);		
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To get the number of files that processed, failed, where queued and failed to
		//			queue since StartProcessing was called.
		[id(47), helpstring("method GetCounts")] HRESULT GetCounts([out] long* plNumProcessedSuccessfully,
			[out] long* plNumProcessingErrors, [out] long* plNumSupplied, [out] long* plNumSupplyingErrors);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets whether the DB password is required to perform processing.
		[propget, id(48), helpstring("property IsDBPasswordRequired")] HRESULT IsDBPasswordRequired(
			[out, retval] VARIANT_BOOL* pvbIsDBPasswordRequired);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets the name of the Action to process with tags expanded
		[id(49), helpstring("method GetExpandedActionName")] HRESULT GetExpandedActionName(
			[out, retval] BSTR* pbstrAction);
		//-----------------------------------------------------------------------------------------
		// Sets the number of documents to process
		[propput, id(50), helpstring("property NumberOfDocsToProcess")] HRESULT
			NumberOfDocsToProcess([in] long lNumberOfDocsToProcess);
		//-----------------------------------------------------------------------------------------
		// Gets whether user authentication is required to start processing.
		[propget, id(51), helpstring("property IsUserAuthenticationRequired")] HRESULT
			IsUserAuthenticationRequired([out, retval] VARIANT_BOOL* pvbIsAuthenticationRequired);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Processes only the specified file regardless of what other files are queued and
		// what their priorities are.
		// ARGS:	vbQueue- VARIANT_TRUE if the file should be added to the queue for the current
		//			action.
		//			vbProcessed- VARIANT_TRUE if the file processing tasks should be executed so
		//			long as the file is queued as pending or skipped (depending on the skipped file
		//			processing setting).
		//			vbForceProcessing- If VARIANT_TRUE and if the file is already present when
		//			queueing its EActionStatus will be reset to kActionPending. Cannot be
		//			VARIANT_TRUE if vbQueue is VARIANT_FALSE. 
		//			nFilePriority- The priority to be assigned to a file being queued. Ignored if
		//			vbQueue is VARIANT_FALSE
		[id(52), helpstring("method ProcessSingleFile")] HRESULT ProcessSingleFile(
			[in] BSTR bstrSourceDocName, [in] VARIANT_BOOL vbQueue, [in] VARIANT_BOOL vbProcess,
			[in] VARIANT_BOOL vbForceProcessing, [in] EFilePriority eFilePriority);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Prompts for user and DB admin passwords as appropriate to run. 
		// RETURNS: VARIANT_TRUE if processing is allowed to run, VARIANT_FALSE if the user was
		//			prompted for a password they did not correctly enter.
		[id(53), helpstring("method AuthenticateForProcessing")] HRESULT AuthenticateForProcessing(
			[out, retval] VARIANT_BOOL* pvbAuthenticated);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets/sets the number of files to queue from the DB when processing
		[propget, id(54), helpstring("property MaxFilesFromDB")] HRESULT
			MaxFilesFromDB([out, retval] long* pVal);
		[propput, id(54), helpstring("property MaxFilesFromDB")] HRESULT
			MaxFilesFromDB([in] long newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To authenticate that the FileProcessingManager is being started
		//			from a valid Extract service.
		[id(55), helpstring("method AuthenticateService")] HRESULT AuthenticateService(
			[in] BSTR bstrValue);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets and sets database connection string properties that should override or be
		// used in additional to the default connection string properties.
		// NOTE:	The value may be a path tag expression to be evaluated. 
		[propput, id(56), helpstring("property AdvancedConnectionStringProperties")]
			HRESULT AdvancedConnectionStringProperties([in] BSTR newVal);		
		[propget, id(56), helpstring("property AdvancedConnectionStringProperties")]
			HRESULT AdvancedConnectionStringProperties([out, retval] BSTR* pVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Retrieves a message warning about any potential configuration issues. If there
		//			are not potential configuration issues, pbstrWarning == __nullptr
		[id(57), helpstring("method GetConfigurationWarnings")] HRESULT GetConfigurationWarnings(
			[out, retval] BSTR *pbstrWarning);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Refreshes the database settings so that if tags are being used the latest
		//			values in the customDB are used
		[id(58), helpstring("method RefreshDBSettings")] HRESULT RefreshDBSettings();
		// PROMISE: Sets and Gets the currently active workflow
		[propget, id(59), helpstring("property ActiveWorkflow ")] HRESULT ActiveWorkflow([out, retval] BSTR* pbstrWorkflowName);
		[propput, id(59), helpstring("property ActiveWorkflow ")] HRESULT ActiveWorkflow([in] BSTR bstrWorkflowName);
		// PROMISE: Sets and Gets whether an admin login is required to edit the settings
		[propget, id(60), helpstring("property RequireAdminEdit ")] HRESULT RequireAdminEdit([out, retval] VARIANT_BOOL* pvbRequireAdminEdit);
		[propput, id(60), helpstring("property RequireAdminEdit ")] HRESULT RequireAdminEdit([in] VARIANT_BOOL bRequireAdminEdit);
		// PROMISE: Waits for processing to complete
		[id(61), helpstring("method WaitForProcessingCompleted")] HRESULT WaitForProcessingCompleted();
		// PROMISE: Gets whether any of the processing Displays a UI
		[propget, id(62), helpstring("property ProcessingDisplaysUI")] HRESULT ProcessingDisplaysUI([out, retval] VARIANT_BOOL* pProcessingDisplaysUI);
		//-----------------------------------------------------------------------------------------
		// RETURNS: The connection string used to connect based on the current database server,
		//			name and advanced connection string properties.
		// NOTE:	Throws an exception if the database server and name have not been specified.
		[propget, id(63), helpstring("property ConnectionString")]
		HRESULT ConnectionString([out, retval] BSTR* pbstrConnectionString);
	};

	[
		object,
		uuid(959FDDBF-6566-4545-AB16-CA4B06BC4721),
		dual,
		helpstring("IFileSupplier Interface"),
		pointer_default(unique)
	]
	interface IFileSupplier : IDispatch
	{
		[id(1), helpstring("method Start")] HRESULT Start([in] IFileSupplierTarget* pTarget, [in] IFAMTagManager* pFAMTM,
			[in] IFileProcessingDB* pDB, [in] long nActionID);
		[id(2), helpstring("method Stop")] HRESULT Stop();
		[id(3), helpstring("method Pause")] HRESULT Pause();
		[id(4), helpstring("method Resume")] HRESULT Resume();
	};

	[
		object,
		uuid(DE49D7B3-FA8D-45a1-A753-93B558B37E5F),
		dual,
		helpstring("IFileSupplierTarget Interface"),
		pointer_default(unique)
	]
	interface IFileSupplierTarget : IDispatch
	{
		[id(1), helpstring("method NotifyFileAdded")] HRESULT NotifyFileAdded([in] BSTR bstrFile, [in] IFileSupplier* pSupplier,
			[out, retval] IFileRecord** ppFileRecord);
		[id(2), helpstring("method NotifyFileRemoved")] HRESULT NotifyFileRemoved([in] BSTR bstrFile, [in] IFileSupplier* pSupplier);
		[id(3), helpstring("method NotifyFileRenamed")] HRESULT NotifyFileRenamed([in] BSTR bstrOldFile, [in] BSTR bstrNewFile, 
			[in] IFileSupplier* pSupplier);
		[id(4), helpstring("method NotifyFolderDeleted")] HRESULT NotifyFolderDeleted([in] BSTR bstrFolder, [in] IFileSupplier* pSupplier);
		[id(5), helpstring("method NotifyFolderRenamed")] HRESULT NotifyFolderRenamed([in] BSTR bstrOldFolder, [in] BSTR bstrNewFolder, 
			[in] IFileSupplier* pSupplier);
		[id(6), helpstring("method NotifyFileModified")] HRESULT NotifyFileModified([in] BSTR bstrFile, [in] IFileSupplier* pSupplier);
		[id(7), helpstring("method NotifyFileSupplyingDone")] HRESULT NotifyFileSupplyingDone([in] IFileSupplier* pSupplier);
		[id(8), helpstring("method NotifyFileSupplyingFailed")] HRESULT NotifyFileSupplyingFailed([in] IFileSupplier* pSupplier, [in] BSTR strError);
	};

	[
		object,
		uuid(D1BD7E04-EE36-472c-873B-9EE9AFB83F4D),
		dual,
		helpstring("IFAMCondition Interface"),
		pointer_default(unique)
	]
	interface IFAMCondition : IAccessRequired
	{
		[id(1), helpstring("method FileMatchesFAMCondition")] HRESULT FileMatchesFAMCondition(
			[in] IFileRecord* pFileRecord, [in] IFileProcessingDB* pFPDB, 
			[in] long lActionID, [in] IFAMTagManager* pFAMTagManager, 
			[out, retval] VARIANT_BOOL* pRetVal);
	};

	[
		object,
		uuid(FC25A9BB-5F7D-42B0-8ABB-7610A4C6CFA7),
		dual,
		helpstring("IPaginationCondition Interface"),
		pointer_default(unique)
	]
	interface IPaginationCondition : IDispatch
	{
		// Used to allow PaginationTask to inform IPaginationCondition implementers when they are
		// being used in the context of the IPaginationCondition interface.
		// NOTE: While it is not necessary for implementers to persist this setting, this setting
		// does need to be copied in the context of the ICopyableObject interface (CopyFrom)
		[propget, id(1), helpstring("property IsPaginationCondition")] HRESULT IsPaginationCondition([out, retval] VARIANT_BOOL* pbIsPaginationCondition);
		[propput, id(1), helpstring("property IsPaginationCondition ")] HRESULT IsPaginationCondition([in] VARIANT_BOOL bIsPaginationCondition);
		// Tests whether a specific proposed pagination output document matches on the specified condition
		// pSourceFileRecord:		Represents the source document which may have multiple other proposed output documents
		// bstrProposedFileName:	The filename this document would assume if created.
		// bstrSerializedDocumentAttributes: A searialized copy of all attributes that fall under a root-level "Document"
		//							attribute including Pages, DeletedPages and DocumentData
		//							(the content of which would become the output document's voa)
		[id(2), helpstring("method FileMatchesPaginationCondition")] HRESULT FileMatchesPaginationCondition(
			[in] IFileRecord* pSourceFileRecord, [in] BSTR bstrProposedFileName, 
			[in] BSTR bstrDocumentStatus, [in] BSTR bstrSerializedDocumentAttributes,
			[in] IFileProcessingDB* pFPDB, [in] long lActionID, [in] IFAMTagManager* pFAMTagManager,
			[out, retval] VARIANT_BOOL* pRetVal);
	};

	[
		object,
		uuid(57735366-4759-4177-899A-EE79EE2FF007),
		dual,
		helpstring("IFAMCancelable Interface"),
		pointer_default(unique)
	]
	interface IFAMCancelable : IDispatch
	{
		[id(1), helpstring("method Cancel")] HRESULT Cancel();
		[id(2), helpstring("method IsCanceled")] HRESULT IsCanceled([out, retval] VARIANT_BOOL *pvbCanceled);
	};
	
	[
		object,
		uuid(5D813089-61BF-46F5-BF5F-7DE4933EDE63),
		dual,
		helpstring("IFAMProcessingResult Interface"),
		pointer_default(unique)
	]
	interface IFAMProcessingResult : IDispatch
	{
		[id(1), helpstring("method GetResult")] HRESULT GetResult([out, retval] EFileProcessingResult* pResult);
	};
	
	[
		object,
		uuid(44DDA42B-DFC4-4E2F-9F9A-73465725E2B4),
		dual,
		helpstring("IInitClose Interface"),
		pointer_default(unique)
	]
	interface IInitClose : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		To alert the object that processing is about to start so it can 
		//				perform any necessary initialization.
		// ARGUMENTS:	nActionID - The ID of the action being processed
		//				pFAMTM - A FAMTagManager object for expanding filename tags/methods
		//				pDB - The database being operated upon
		//				pFileRequestHandler- The IFileRequestHandler that can be used
        //				by the task to carry out requests for files to be checked out, released or
		//				re-ordered in the queue.
		// NOTE:		This may be called multiple times on the same object because the same coClass
		//				may be being used in multiple threads.  This will happen per processing session
		//				not per file.
		//				See note about IFileProcessingTask multithreading above
		[id(11), helpstring("method Init")] HRESULT Init([in] long nActionID,
			[in] IFAMTagManager* pFAMTM, [in] IFileProcessingDB* pDB,
			[in] IFileRequestHandler* pFileRequestHandler);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:		To notify a object that the processing has been completed.
		//				(allowing the object to perform any cleanup it may wish to do)
		// NOTE:		This may be called multiple times on the same object because the same coClass
		//				may be being used in multiple threads. This will happen per processing session
		//				not per file
		[id(2), helpstring("method Close")] HRESULT Close();		
	};

	[
		object,
		uuid(B4690765-4695-4D25-8F79-3F34C72AC4CB),
		dual,
		helpstring("IWorkItemRecord Interface"),
		pointer_default(unique)
	]
	interface IWorkItemRecord : IDispatch
	{
		[propget, id(1), helpstring ("property WorkItemID")] HRESULT WorkItemID([out, retval] long *pnWorkItemID);
		[propput, id(1), helpstring ("property WorkItemID")] HRESULT WorkItemID([in] long nWorkItemID);
		[propget, id(2), helpstring ("property WorkItemGroupID")] HRESULT WorkItemGroupID([out, retval] long *pnWorkItemGroupID);
		[propput, id(2), helpstring ("property WorkItemGroupID")] HRESULT WorkItemGroupID([in] long nWorkItemGroupID);
		[propget, id(3), helpstring ("property Status")] HRESULT Status([out, retval] EWorkItemStatus *pStatus);
		[propput, id(3), helpstring ("property Status")] HRESULT Status([in] EWorkItemStatus Status);
		[propget, id(4), helpstring ("property Input")] HRESULT Input([out, retval] BSTR *pInput);
		[propput, id(4), helpstring ("property Input")] HRESULT Input([in] BSTR Input);
		[propget, id(5), helpstring ("property Output")] HRESULT Output([out, retval] BSTR *pOutput);
		[propput, id(5), helpstring ("property Output")] HRESULT Output([in] BSTR Output);
		[propget, id(6), helpstring ("property FAMSessionID")] HRESULT FAMSessionID([out, retval] long *pnFAMSessionID);
		[propput, id(6), helpstring ("property FAMSessionID")] HRESULT FAMSessionID([in] long nFAMSessionID);
		[propget, id(7), helpstring ("property StringizedException")] HRESULT StringizedException([out, retval] BSTR *pStringizedException);
		[propput, id(7), helpstring ("property StringizedException")] HRESULT StringizedException([in] BSTR StringizedException);
		
		// The FileName will always be populated in methods that return WorkItemRecords.  
		//(SEE WorkItem related functions on IFileProcessingDB
		[propget, id(8), helpstring ("property FileName")] HRESULT FileName([out, retval] BSTR *pFileName);
		[propput, id(8), helpstring ("property FileName")] HRESULT FileName([in] BSTR FileName);

		// The BinaryOutput property is used to save a streamable object to the BinaryOutput field 
		// in the WorkItem table
		[propget, id(9), helpstring ("property BinaryOutput")] HRESULT BinaryOutput([out, retval] IUnknown **ppBinaryOutput);
		[propput, id(9), helpstring ("property BinaryOutput")] HRESULT BinaryOutput([in] IUnknown *pBinaryOutput);

		[propget, id(10), helpstring ("property BinaryInput")] HRESULT BinaryInput([out, retval] IUnknown **ppBinaryInput);
		[propput, id(10), helpstring ("property BinaryInput")] HRESULT BinaryInput([in] IUnknown *pBinaryInput);

		[propget, id(11), helpstring ("property FileID")] HRESULT FileID([out, retval] long *pnFileID);
		[propput, id(11), helpstring ("property FileID")] HRESULT FileID([in] long nFileID);

		[propget, id(12), helpstring ("property WorkGroupFAMSessionID")] HRESULT WorkGroupFAMSessionID([out, retval] long *pnFAMSessionID);
		[propput, id(12), helpstring ("property WorkGroupFAMSessionID")] HRESULT WorkGroupFAMSessionID([in] long nFAMSessionID);
		
		[propget, id(13), helpstring("property Priority")] HRESULT Priority(
			[out, retval] EFilePriority* pePriority);
		[propput, id(13), helpstring("property Priority")] HRESULT Priority(
			[in] EFilePriority ePriority);

		[propget, id(14), helpstring ("property RunningTaskDescription")] HRESULT RunningTaskDescription([out, retval] BSTR *pOutput);
		[propput, id(14), helpstring ("property RunningTaskDescription")] HRESULT RunningTaskDescription([in] BSTR Input);
	}

	[
		object,
		uuid(B4011132-F37E-4274-88E4-D11173E1C579),
		dual,
		helpstring("IWorkflowDefinition Interface"),
		pointer_default(unique)
	]
	interface IWorkflowDefinition : IDispatch
	{
		[propget, id(1), helpstring ("property ID")] HRESULT ID([out, retval] long* pnID);
		[propput, id(1), helpstring ("property ID")] HRESULT ID([in] long nID);
		[propget, id(2), helpstring ("property Name")] HRESULT Name([out, retval] BSTR* pName);
		[propput, id(2), helpstring ("property Name")] HRESULT Name([in] BSTR Name);
		[propget, id(3), helpstring ("property Type")] HRESULT Type([out, retval] EWorkflowType* pWorkflowType);
		[propput, id(3), helpstring ("property Type")] HRESULT Type([in] EWorkflowType WorkflowType);
		[propget, id(4), helpstring ("property Description")] HRESULT Description([out, retval] BSTR* pDescription);
		[propput, id(4), helpstring ("property Description")] HRESULT Description([in] BSTR Description);
		[propget, id(5), helpstring ("property StartAction")] HRESULT StartAction([out, retval] BSTR* pStartAction);
		[propput, id(5), helpstring ("property StartAction")] HRESULT StartAction([in] BSTR StartAction);
		[propget, id(6), helpstring ("property EndAction")] HRESULT EndAction([out, retval] BSTR* pEndAction);
		[propput, id(6), helpstring ("property EndAction")] HRESULT EndAction([in] BSTR EndAction);
		[propget, id(7), helpstring ("property PostWorkflowAction")] HRESULT PostWorkflowAction([out, retval] BSTR* pPostWorkflowAction);
		[propput, id(7), helpstring ("property PostWorkflowAction")] HRESULT PostWorkflowAction([in] BSTR PostWorkflowAction);
		[propget, id(8), helpstring ("property DocumentFolder")] HRESULT DocumentFolder([out, retval] BSTR* pDocumentFolder);
		[propput, id(8), helpstring ("property DocumentFolder")] HRESULT DocumentFolder([in] BSTR DocumentFolder);
		[propget, id(9), helpstring ("property OutputAttributeSet")] HRESULT OutputAttributeSet([out, retval] BSTR* pOutputAttributeSet);
		[propput, id(9), helpstring ("property OutputAttributeSet")] HRESULT OutputAttributeSet([in] BSTR OutputAttributeSet);
		[propget, id(10), helpstring ("property OutputFileMetadataField")] HRESULT OutputFileMetadataField([out, retval] BSTR* pOutputAttributeSet);
		[propput, id(10), helpstring ("property OutputFileMetadataField")] HRESULT OutputFileMetadataField([in] BSTR OutputAttributeSet);
		[propget, id(11), helpstring ("property OutputFilePathInitializationFunction")] HRESULT OutputFilePathInitializationFunction([out, retval] BSTR* pVal);
		[propput, id(11), helpstring ("property OutputFilePathInitializationFunction")] HRESULT OutputFilePathInitializationFunction([in] BSTR newVal);
		[propget, id(12), helpstring ("property LoadBalanceWeight")] HRESULT LoadBalanceWeight([out, retval] long* pnWeight);
		[propput, id(12), helpstring ("property LoadBalanceWeight")] HRESULT LoadBalanceWeight([in] long nWeight);		
		// Action that should be tied to attribute updates made via web API users or web applications
		[propget, id(13), helpstring ("property EditAction")] HRESULT EditAction([out, retval] BSTR* pEditAction);
		[propput, id(13), helpstring ("property EditAction")] HRESULT EditAction([in] BSTR EditAction);
		// Action to be set run following and attribute data edit made via web API users or web applications
		[propget, id(14), helpstring ("property PostEditAction")] HRESULT PostEditAction([out, retval] BSTR* pPostEditAction);
		[propput, id(14), helpstring ("property PostEditAction")] HRESULT PostEditAction([in] BSTR PostEditAction);
	}

	[
		object,
		uuid(ABE5C40D-E730-4300-BF38-5E7F890B6C59),
		dual,
		helpstring("IParallelizableTask Interface"),
		pointer_default(unique)
	]
	interface IParallelizableTask : IDispatch
	{
		[id(1), helpstring("method ProcessWorkItem")] HRESULT ProcessWorkItem([in] IWorkItemRecord *pWorkItem,
			[in] long nActionID, [in] IFAMTagManager* pFAMTM, [in] IFileProcessingDB* pDB, 
			[in] IProgressStatus *pProgressStatus);
		[propget, id(2), helpstring("property Parallelize")] HRESULT Parallelize([out,retval] VARIANT_BOOL *pVal);
		[propput, id(2), helpstring("property Parallelize")] HRESULT Parallelize([in] VARIANT_BOOL newVal);
	};

	[
		object,
		uuid(625BB300-D5AC-476D-8DC8-893DCE2C0143),
		dual,
		nonextensible,
		helpstring("IActionStatistics Interface"),
		pointer_default(unique)
	]
	interface IActionStatistics : IDispatch{
		[propget, id(1), helpstring("property NumDocuments")] HRESULT NumDocuments([out, retval] long* pVal);
		[propput, id(1), helpstring("property NumDocuments")] HRESULT NumDocuments([in] long newVal);
		[propget, id(2), helpstring("property NumDocumentsComplete")] HRESULT NumDocumentsComplete([out, retval] long* pVal);
		[propput, id(2), helpstring("property NumDocumentsComplete")] HRESULT NumDocumentsComplete([in] long newVal);
		[propget, id(3), helpstring("property NumDocumentsFailed")] HRESULT NumDocumentsFailed([out, retval] long* pVal);
		[propput, id(3), helpstring("property NumDocumentsFailed")] HRESULT NumDocumentsFailed([in] long newVal);
		[propget, id(4), helpstring("property NumPages")] HRESULT NumPages([out, retval] long* pVal);
		[propput, id(4), helpstring("property NumPages")] HRESULT NumPages([in] long newVal);
		[propget, id(5), helpstring("property NumPagesComplete")] HRESULT NumPagesComplete([out, retval] long* pVal);
		[propput, id(5), helpstring("property NumPagesComplete")] HRESULT NumPagesComplete([in] long newVal);
		[propget, id(6), helpstring("property NumPagesFailed")] HRESULT NumPagesFailed([out, retval] long* pVal);
		[propput, id(6), helpstring("property NumPagesFailed")] HRESULT NumPagesFailed([in] long newVal);
		[propget, id(7), helpstring("property NumBytes")] HRESULT NumBytes([out, retval] LONGLONG* pVal);
		[propput, id(7), helpstring("property NumBytes")] HRESULT NumBytes([in] LONGLONG newVal);
		[propget, id(8), helpstring("property NumBytesComplete")] HRESULT NumBytesComplete([out, retval] LONGLONG* pVal);
		[propput, id(8), helpstring("property NumBytesComplete")] HRESULT NumBytesComplete([in] LONGLONG newVal);
		[propget, id(9), helpstring("property NumBytesFailed")] HRESULT NumBytesFailed([out, retval] LONGLONG* pVal);
		[propput, id(9), helpstring("property NumBytesFailed")] HRESULT NumBytesFailed([in] LONGLONG newVal);
		[propget, id(10), helpstring("property NumDocumentsSkipped")] HRESULT NumDocumentsSkipped([out, retval] long* pVal);
		[propput, id(10), helpstring("property NumDocumentsSkipped")] HRESULT NumDocumentsSkipped([in] long newVal);
		[propget, id(11), helpstring("property NumPagesSkipped")] HRESULT NumPagesSkipped([out, retval] long* pVal);
		[propput, id(11), helpstring("property NumPagesSkipped")] HRESULT NumPagesSkipped([in] long newVal);
		[propget, id(12), helpstring("property NumBytesSkipped")] HRESULT NumBytesSkipped([out, retval] LONGLONG* pVal);
		[propput, id(12), helpstring("property NumBytesSkipped")] HRESULT NumBytesSkipped([in] LONGLONG newVal);
		[id(13), helpstring("method GetAllStatistics")] HRESULT GetAllStatistics([out] long* plNumDocuments, 
			[out] long* plNumDocsPending, [out] long* plNumDocsCompleted, [out] long* plNumDocsFailed, 
			[out] long* plNumDocsSkipped, [out] long* plNumPages, [out] long* plNumPagesPending, 
			[out] long* plNumPagesCompleted, [out] long* plNumPagesFailed, [out] long* plNumPagesSkipped, 
			[out] LONGLONG* pllNumBytes, [out] LONGLONG* pllNumBytesPending, [out] LONGLONG* pllNumBytesCompleted,
			[out] LONGLONG* pllNumBytesFailed, [out] LONGLONG* pllNumBytesSkipped);
		[id(14), helpstring("method SetAllStatistics")] HRESULT SetAllStatistics([in] long lNumDocuments,
			[in] long lNumDocumentsPending ,[in] long lNumDocsCompleted, [in] long lNumDocsFailed, 
			[in] long lNumDocsSkipped, [in] long lNumPages, [in] long lNumPagesPending, 
			[in] long lNumPagesCompleted, [in] long lNumPagesFailed, [in] long lNumPagesSkipped, 
			[in] LONGLONG llNumBytes, [in] LONGLONG llNumBytesPending, [in] LONGLONG llNumBytesCompleted,
			[in] LONGLONG llNumBytesFailed, [in] LONGLONG llNumBytesSkipped);
		[id(15), helpstring("method GetTotals")] HRESULT GetTotals([out] long* plNumDocuments,
			[out] long* plNumPages, [out] LONGLONG* pllNumBytes);
		[id(16), helpstring("method SetTotals")] HRESULT SetTotals([in] long lNumDocuments,
			[in] long lNumPages, [in] LONGLONG llNumBytes);
		[id(17), helpstring("method GetComplete")] HRESULT GetComplete([out] long* plNumDocsComplete,
			[out] long* plNumPagesComplete, [out] LONGLONG* pllNumBytesComplete);
		[id(18), helpstring("method SetComplete")] HRESULT SetComplete([in] long lNumDocsComplete,
			[in] long lNumPagesComplete, [in] LONGLONG llNumBytesComplete);
		[id(19), helpstring("method GetFailed")] HRESULT GetFailed([out] long* plNumDocsFailed,
			[out] long* plNumPagesFailed, [out] LONGLONG* pllNumBytesFailed);
		[id(20), helpstring("method SetFailed")] HRESULT SetFailed([in] long lNumDocsFailed,
			[in] long lNumPagesFailed, [in] LONGLONG llNumBytesFailed);
		[id(21), helpstring("method GetSkipped")] HRESULT GetSkipped([out] long* plNumDocsSkipped,
			[out] long* plNumPagesSkipped, [out] LONGLONG* pllNumBytesSkipped);
		[id(22), helpstring("method SetSkipped")] HRESULT SetSkipped([in] long lNumDocsSkipped,
			[in] long lNumPagesSkipped, [in] LONGLONG llNumBytesSkipped);
		[id(23), helpstring("method GetPending")] HRESULT GetPending([out] long* plNumDocsPending,
			[out] long* plNumPagesPending, [out] LONGLONG* pllNumBytesPending);
		[id(24), helpstring("method SetPending")] HRESULT SetPending([in] long lNumDocsPending,
			[in] long lNumPagesPending, [in] LONGLONG llNumBytesPending);			
		[propget, id(25), helpstring("property NumDocumentsPending")] HRESULT NumDocumentsPending([out, retval] long* pVal);
		[propput, id(25), helpstring("property NumDocumentsPending")] HRESULT NumDocumentsPending([in] long newVal);
		[propget, id(26), helpstring("property NumPagesPending")] HRESULT NumPagesPending([out, retval] long* pVal);
		[propput, id(26), helpstring("property NumPagesPending")] HRESULT NumPagesPending([in] long newVal);
		[propget, id(27), helpstring("property NumBytesPending")] HRESULT NumBytesPending([out, retval] LONGLONG* pVal);
		[propput, id(27), helpstring("property NumBytesPending")] HRESULT NumBytesPending([in] LONGLONG newVal);
		[id(28), helpstring("method AddStatistics")] HRESULT AddStatistics([in] IActionStatistics *pActionStats);
	};

	[
		object,
		uuid(5971B2FF-7604-4BC9-AD94-30320D33EA06),
		dual,
		nonextensible,
		helpstring("IFileRecord Interface"),
		pointer_default(unique)
	]
	interface IFileRecord : IDispatch{
		[propget, id(1), helpstring("property FileID")] HRESULT FileID([out, retval] LONG* pVal);
		[propput, id(1), helpstring("property FileID")] HRESULT FileID([in] LONG newVal);
		[propget, id(2), helpstring("property Name")] HRESULT Name([out, retval] BSTR* pVal);
		[propput, id(2), helpstring("property Name")] HRESULT Name([in] BSTR newVal);
		[propget, id(3), helpstring("property FileSize")] HRESULT FileSize([out, retval] LONGLONG* pVal);
		[propput, id(3), helpstring("property FileSize")] HRESULT FileSize([in] LONGLONG newVal);
		[propget, id(4), helpstring("property Pages")] HRESULT Pages([out, retval] LONG* pVal);
		[propput, id(4), helpstring("property Pages")] HRESULT Pages([in] LONG newVal);
		[propget, id(5), helpstring("property ActionID")] HRESULT ActionID([out, retval] LONG* pVal);
		[propput, id(5), helpstring("property ActionID")] HRESULT ActionID([in] LONG pVal);
		[id(6), helpstring("method GetFileData")] HRESULT GetFileData(
			[out] LONG* plFileID, [out] LONG* plActionID, [out] BSTR* pbstrFileName,
			[out] LONGLONG* pllFileSize, [out] LONG* plPages, [out] EFilePriority* pePriority,
			[out] LONG* plWorkflowID);
		[id(7), helpstring("method SetFileData")] HRESULT SetFileData(
			[in] LONG lFileID, [in] LONG lActionID, [in] BSTR bstrFileName,
			[in] LONGLONG llFileSize, [in] LONG lPages, [in] EFilePriority ePriority,
			[in] LONG lWorkflowID);
		[propget, id(8), helpstring("property Priority")] HRESULT Priority(
			[out, retval] EFilePriority* pePriority);
		[propput, id(8), helpstring("property Priority")] HRESULT Priority(
			[in] EFilePriority ePriority);
		// Specifies the EActionStatus a currently processing record will return to if processing
		// is cancelled. This will be the status before lock unless otherwise updated.
		[propget, id(9), helpstring("property FallbackStatus")] HRESULT FallbackStatus(
			[out, retval] EActionStatus* peaFallbackStatus);
		[propput, id(9), helpstring("property FallbackStatus")] HRESULT FallbackStatus(
			[in] EActionStatus eaFallbackStatus);
		[propget, id(10), helpstring("property WorkflowID")] HRESULT WorkflowID([out, retval] LONG* pVal);
		[propput, id(10), helpstring("property WorkflowID")] HRESULT WorkflowID([in] LONG newVal);
	};

	[
		object,
		uuid(27E77AFF-2D7D-4D3E-A415-9D6AAB78A257),
		dual,
		nonextensible,
		helpstring("IFileProcessingDB Interface"),
		pointer_default(unique)
	]
	interface IFileProcessingDB : IDispatch
	{
		// TODO: discuss "multiple file" versions of the methods below

		// -----------------------------------------------------------------------------------------------
		// Methods related to actions
		// -----------------------------------------------------------------------------------------------
		// REQUIRE:	strAction must not contain any spaces, and must match the regex [a-zA-Z_][a-zA-Z0-9_]*
		//			strAction must be a new action (i.e. one that is not already defined in the database)
		// PROMISE:	To update the FPMFile table with a new column with the name "ASC_{strAction}" and to
		//			add a new record in the Action table. The ID of the newly defined action in the 
		//			Action table will be returned.
		// NOTE:	The addition of the new record to the Action table and the addition of the column to
		//			the FPMFile table should be done within a transaction so that both operations pass or
		//			fail.
		[id(1), helpstring("method DefineNewAction")] HRESULT DefineNewAction([in] BSTR strAction,
			[out, retval] long* pnID);
		// -----------------------------------------------------------------------------------------------
		// REQUIRE:	strAction must be a current existing action.
		// PROMISE:	To delete the record associated with strAction from the Action table, and to delete
		//			the "ASC_{strAction}" column from the FPMFile table.  Also, all records that reference 
		//			strAction in other tables will be deleted.
		// NOTE:	All the above database operations shall be executed within a transaction.
		[id(2), helpstring("method DeleteAction")] HRESULT DeleteAction([in] BSTR strAction);
		// -----------------------------------------------------------------------------------------------
		// PROMISE:	To return a StringToLong map of all actions and their corresponding IDs in the 
		//			database.
		[id(3), helpstring("method GetActions")] HRESULT GetActions(
			[out,retval] IStrToStrMap ** pmapActionNameToID);

		// -----------------------------------------------------------------------------------------------
		// Methods related to adding/removing files
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To add the file to the database.
		//			if the bForceStatusChange flag is VARIANT_FALSE
		//				if file is not in the database or current status is kActionUnattempted will be added 
		//				the file will be added and the status will be set to the eNewStatus value
		//				otherwise the status will be unchanged
		//			if the bForceStatusChange flag is VARINT_TRUE
		//				The file will be added to the database if it is not in the database
		//				and the current status of the file is not kActionProcessing the status of the file
		//				will be changed to eNewStatus
		//			if the bSkipPageCount is VARIANT_TRUE
		//				When files are queued, no attempt will be made to check the page count.
		// 
		[id(4), helpstring("method AddFile")] HRESULT AddFile([in] BSTR strFile, [in] BSTR strAction, [in] long nWorkflowID,
			[in] EFilePriority ePriority, [in] VARIANT_BOOL bForceStatusChange, [in] VARIANT_BOOL bFileModified, 
			[in] EActionStatus eNewStatus, [in] VARIANT_BOOL bSkipPageCount, [out] VARIANT_BOOL* pbAlreadyExists,
			[out] EActionStatus* pPrevStatus, [out, retval] IFileRecord** ppFileRecord);
		// -----------------------------------------------------------------------------------------------
		// PROMISE:	Remove the file by setting the given actions's status to "U" if the current state is "P"
		//			Also a record will always be added to the QueueEvent table
		//			if the action state of the file changed the FileActionStateTransition will have a record added
		[id(5), helpstring("method RemoveFile")] HRESULT RemoveFile([in] BSTR strFile, [in] BSTR strAction);
		// -----------------------------------------------------------------------------------------------
		// PROMISE:	Removes (sets the Action Status to "U") all files in FPMFile that are in the given folder
		//			Also a record will always be added to the QueueEvent table for each file
		//			if the action state of the file changed the FileActionStateTransition will have a record added
		[id(15), helpstring("method RemoveFolder")] HRESULT RemoveFolder([in] BSTR strFolder, [in] BSTR strAction);

		// -----------------------------------------------------------------------------------------------
		// Methods related to setting / getting file status
		// -----------------------------------------------------------------------------------------------
		[id(6), helpstring("method NotifyFileProcessed")] HRESULT NotifyFileProcessed([in] long nFileID, 
			[in] BSTR strAction, [in] long nWorkflowID, [in] VARIANT_BOOL vbAllowQueuedStatusOverride);
		[id(7), helpstring("method NotifyFileFailed")] HRESULT NotifyFileFailed([in] long nFileID, 
			[in] BSTR strAction, [in] long nWorkflowID, [in] BSTR strException,
			[in] VARIANT_BOOL vbAllowQueuedStatusOverride);
		// For the SetFileStatusTo methods, if vbAllowQueuedStatusOverride is VARIANT_TRUE and the
		// QueuedActionStatusChange table has a pending change for the file, that change will be applied.
		// If vbAllowQueuedStatusOverride is VARIANT_FALSE, the QueuedActionStatusChange will be ignored.
		[id(8), helpstring("method SetFileStatusToPending")] HRESULT SetFileStatusToPending([in] long nFileID, 
			[in] BSTR strAction, /*[in] long nWorkflowID, */[in] VARIANT_BOOL vbAllowQueuedStatusOverride);
		[id(9), helpstring("method SetFileStatusToUnattempted")] HRESULT SetFileStatusToUnattempted([in] long nFileID, 
			[in] BSTR strAction, /*[in] long nWorkflowID, */[in] VARIANT_BOOL vbAllowQueuedStatusOverride);
		[id(10), helpstring("method GetFileStatus")] HRESULT GetFileStatus([in] long nFileID, [in] BSTR strAction,
			[in] VARIANT_BOOL vbAttemptRevertIfLocked, [out, retval] EActionStatus* pStatus);

		// id(11): Removed unused SearchAndModifyFileStatus

		[id(12), helpstring("method SetStatusForAllFiles")] HRESULT SetStatusForAllFiles([in] BSTR strAction, 
			[in] EActionStatus eStatus);

		// -----------------------------------------------------------------------------------------------
		// REQUIRE:	strAction is a valid action defined in the Action table
		//			nID is a valid file ID defined in the FPMFile table
		// PROMISE: If pOldStatus != __nullptr, then the old status associated with the file will be returned.
		// NOTE:	If nWorkflowID param == -1 then the current, active workflow will be used to resolve the
		//			action name to an ID.
		//			If vbQueueChangeIfProcessing is VARIANT_TRUE and the file is currently processing, a
		//			change to eStatus will be queued in the QueuedActionStatusChange table. If
		//			VARIANT_FALSE the file action status will be overwritten regardless of its current
		//			processing state.
		//			If vbAllowQueuedStatusOverride is VARIANT_TRUE and the QueuedActionStatusChange table
		//			has a pending change for the file, that change will be applied. If
		//			vbAllowQueuedStatusOverride is VARIANT_FALSE, the QueuedActionStatusChange will be
		//			ignored and the status will be set to eStatus.
		[id(13), helpstring("method SetStatusForFile")] HRESULT SetStatusForFile([in] long nID, [in] BSTR strAction, 
			[in] long nWorkflowID, [in] EActionStatus eStatus, [in] VARIANT_BOOL vbQueueChangeIfProcessing,
			[in] VARIANT_BOOL vbAllowQueuedStatusOverride, [out] EActionStatus* poldStatus);


		// -----------------------------------------------------------------------------------------------
		// Methods to determine the next files to process
		// -----------------------------------------------------------------------------------------------
		// PROMISE:	To return up to nMaxFiles records where the specified action has a status of 'P'
		//			for bGetSkippedFiles == VARIANT_FALSE or 'S' for bGetSkippedFiles == VARIANT_TRUE
		//			For all records returned, the status for the action will be set to 'R' before this
		//			method call returns. If bGetSkippedFiles == VARIANT_TRUE then bstrSkippedForUserName
		//			will be used to determine which skipped files to process. If bstrSkippedForUserName
		//			is NULL or "" then any skipped files for the specified action will be returned
		//			(up to nMaxFiles), if bstrSkippedForUserName is not NULL or "" then will only
		//			return files that have been skipped for the specified action by the specified
		//			user (up to nMaxFiles). If bGetSkippedFiles == true then the list of skipped files
		//			will not contain any file that was skipped in the current run.
		[id(14), helpstring("method GetFilesToProcess")] HRESULT GetFilesToProcess([in] BSTR strAction, 
			[in] long nMaxFiles, [in] VARIANT_BOOL bGetSkippedFiles,
			[in] BSTR bstrSkippedForUserName,
			[out, retval] IIUnknownVector** pvecFileRecords);

		// -----------------------------------------------------------------------------------------------
		// PROMISE: To return a IActionStistics pointer that contains the current stats for the given action
		[id(19), helpstring("method GetStats")] HRESULT GetStats([in] long nActionID,
			[in] VARIANT_BOOL vbForceUpdate, [in, optional] VARIANT_BOOL vbRevertTimedOutFAMs, [out, retval] IActionStatistics** pStats);

		// -----------------------------------------------------------------------------------------------
		// PROMISE: To Clear the database
		// PARAMS:  vbRetainUserValues - Retain user specified actions, tags, and DBInfo settings
		[id(20), helpstring("method Clear")] HRESULT Clear([in] VARIANT_BOOL vbRetainUserValues);

		// PROMISE: To copy the status of the files for the fromAction to the toAction
		[id(21), helpstring("method CopyActionStatusFromAction")] HRESULT CopyActionStatusFromAction([in] long nFromAction, [in] long nToAction);

		// PROMISE: To Rename an action
		[id(22), helpstring("method RenameAction")] HRESULT RenameAction([in] BSTR strOldActionName, [in] BSTR strNewActionName);

		// PROMISE: To output all of the FileName values found by the query strQuery to a file named strOutputFileName
		//			and return the number of records that were exported
		//			If pRandomCondition == NULL then all files returned by the query will be exported,
		//			if pRandomComdition != __nullptr then before each file is exported the condition
		//			will be checked and the file will only be exported if the condition returns true.
		[id(23), helpstring("method ExportFileList")] HRESULT ExportFileList([in] BSTR strQuery, [in] BSTR strOutputFileName,
			[in] IRandomMathCondition* pRandomCondition, [out,retval] long* pnNumRecordsOutput);

		// PROMISE: To clear any existing DB lock - clears all records in the LockTable
		[id(24), helpstring("method ResetDBLock")] HRESULT ResetDBLock(void);

		// PROMISE: To return the ActionID for the given action name, if the action name does not exist an exception will be thrown
		[id(25), helpstring("method GetActionID")] HRESULT GetActionID([in] BSTR bstrActionName, [out, retval]long* pnActionID);

		// PROMISE: To close any existing open connection and reopen with the current settings  
		//			DatebaseServer and DatabaseName 
		// PARAMS:  bResetCredentials- VARIANT_TRUE to force any credentials associated with the current connection.
		[id(26), helpstring("method ResetDBConnection")] HRESULT ResetDBConnection([in] VARIANT_BOOL bResetCredentials,
			[in] VARIANT_BOOL vbCheckForUnnaffiliatedFiles);

		// PROMISE: To send all database connection status and access status update events
		//			to the window represented by the handle nHandle
		[id(27), helpstring("method SetNotificationUIWndHandle")] HRESULT SetNotificationUIWndHandle(long nHandle);

		// PROMISE: To prompt the user for a Username and password if the password is in the DB Login table
		//			and compare the encrypted Username + password combination to the saved password.
		//			if no password is in the Login table will display password dialog to get the new password
		//			and will encrypt the Username + password and save in the database
		[id(28), helpstring("method ShowLogin")] HRESULT ShowLogin([in] VARIANT_BOOL bShowAdmin, 
			[out] VARIANT_BOOL* pbLoginCancelled, 
			[out,retval] VARIANT_BOOL* pbLoginValid);

		// PROMISE: To return the DBSchemaVersion from the DBInfoTable
		[propget, id(29), helpstring("property DBSchemaVersion")] HRESULT DBSchemaVersion([out, retval] LONG* pVal);

		// PROMISE: To prompt the user for a new password.  The encrypted Username + password 
		//			will be saved in the database.
		[id(30), helpstring("method ChangeLogin")] HRESULT ChangeLogin([in] VARIANT_BOOL bChangeAdmin,
			[out] VARIANT_BOOL* pbLoginCancelled, 
			[out,retval] VARIANT_BOOL* pbLoginValid);

		// PROMISE: To get the current database connection status string
		[id(32), helpstring("method GetCurrentConnectionStatus")] HRESULT GetCurrentConnectionStatus([out, retval] BSTR* pVal);

		[propget, id(33), helpstring("property DatabaseServer")] HRESULT DatabaseServer([out, retval] BSTR* pVal);
		[propput, id(33), helpstring("property DatabaseServer")] HRESULT DatabaseServer([in] BSTR newVal);

		[propget, id(34), helpstring("property DatabaseName")] HRESULT DatabaseName([out, retval] BSTR* pVal);
		[propput, id(34), helpstring("property DatabaseName")] HRESULT DatabaseName([in] BSTR newVal);
		
		// PROMISE: To create a new database in the currently set DatabaseServer with the name bstrNewDBName
		// REQUIRES: DatabaseServer property must be set to a valid database server.
		[id(35), helpstring("method CreateNewDB")] HRESULT CreateNewDB([in] BSTR bstrNewDBName, [in] BSTR bstrInitWithPassword);

		// PROMISE: Connects to a database using the last configured database connection this process.
		// NOTE: The connection may be for a database that has not actually been used yet this process.
		// The connection string is based only on the properties of an IFileProcessingDB instance that
		// have been set, not based on a connection  that has actually been opened. Thus, for example,
		// if we are running within a RunFPSFile instance with the /ingoreDB flag, even though the FAM
		// instance will not have connected to a database, the database info will still have been loaded
		// from the FPS file and that is what will be used here.
		[id(36), helpstring("method ConnectLastUsedDBThisProcess ")] HRESULT ConnectLastUsedDBThisProcess();

		// PROMISE: To store a setting in the DBInfo table of the database. 
		// PARAMS:  bstrSettingName - Name of the setting to add
		//          bstrSettingValue - Value of the setting
		//          vbSetIfExists - Whether to set the setting if it already exists.
		//			vbRecordHistory - Whether an entry should be stored in DBInfoChangeHistory.
		// NOTE:	This is to be used by the product specific database managers to store there settings in the
		//			DBInfo table.
		[id(37), helpstring("method SetDBInfoSetting")] HRESULT SetDBInfoSetting(
			[in] BSTR bstrSettingName, [in] BSTR bstrSettingValue, [in] VARIANT_BOOL vbSetIfExists,
			[in] VARIANT_BOOL vbRecordHistory);

		// PROMISE: To return the value for the setting name from the DBInfo table
		// PARAMS:	vbThrowIfMissing- If VARIANT_TRUE, if the setting is missing an exception will be thrown.
		//				If VARIANT_FALSE and the setting is missing, a blank value will be returned.
		[id(38), helpstring("method GetDBInfoSetting")] HRESULT GetDBInfoSetting(
			[in] BSTR bstrSettingName, [in] VARIANT_BOOL vbThrowIfMissing, [out, retval] BSTR* pbstrSettingValue);

		// PROMISE: To lock the specified database lock
		// NOTE:	LockDB cannot be called twice on the same thread without first calling
		//			UnlockDB; doing so will result in an exception. It is expected any subsequent
		//			DB queries be made in this same thread to allow them to run under elevated
		//			deadlock priority. Since calls from the .Net framework thread cannot be
		//			guaranteed to come in on the same system thread, this should not be called
		//			from .Net code. Unless absolutely necessary, it should not be called from
		//			outside the FileProcessingDB class at all.
		//			https://extract.atlassian.net/browse/ISSUE-12328
		//			https://extract.atlassian.net/browse/ISSUE-11597
		[id(39), helpstring("method LockDB_InternalOnly")] HRESULT LockDB_InternalOnly([in] BSTR bstrLockName);

		// PROMISE: To unlock the specified database lock
		// NOTE:	See note for LockDB.
		[id(40), helpstring("method UnlockDB_InternalOnly")] HRESULT UnlockDB_InternalOnly([in] BSTR bstrLockName);
		
		// PROMISE: To return a recordset opened with the results of the query in bstrQuery
		[id(41), helpstring("method GetResultsForQuery")] HRESULT GetResultsForQuery([in] BSTR bstrQuery, 
			[out,retval] _Recordset** ppVal);

		// PROMISE: To take an EActionStatus and return the corresponding string
		[id(42), helpstring("method AsStatusString")] HRESULT AsStatusString(
			[in] EActionStatus eaStatus, [out, retval] BSTR* bstrStatusString);

		// PROMISE: To take an ActionStatus string and return the corresponding
		//			EActionStatus enum
		[id(43), helpstring("method AsEActionStatus")] HRESULT AsEActionStatus(
			[in] BSTR bstrStatusString, [out, retval] EActionStatus* peaStatus);

		// PURPOSE: To get the file ID for a specified file name from the database.
		// if the action name does not exist an exception will be thrown.
		[id(44), helpstring("method GetFileIDFromName")] HRESULT GetFileID(
			[in] BSTR bstrFileName, [out, retval] long* pVal);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get the name of the action from its ID
		[id(45), helpstring("method GetActionName")] HRESULT GetActionName(
			[in] long nActionID, [out, retval] BSTR* pbstrActionName);
		// -----------------------------------------------------------------------------------------------
		[id(46), helpstring("method NotifyFileSkipped")] HRESULT NotifyFileSkipped([in] long nFileID,
			[in] BSTR bstrAction, [in] LONG nWorkflowID, [in] VARIANT_BOOL vbAllowQueuedStatusOverride);

		// -----------------------------------------------------------------------------------------------
		// Methods related to comment strings
		// -----------------------------------------------------------------------------------------------
		[id(47), helpstring("method SetFileActionComment")] HRESULT SetFileActionComment(
			[in] long nFileID, [in] long nActionID, [in] BSTR bstrComment);
		// -----------------------------------------------------------------------------------------------
		[id(48), helpstring("method GetFileActionComment")] HRESULT GetFileActionComment(
			[in] long nFileID, [in] long nActionID, [out, retval] BSTR* pbstrComment);
		// -----------------------------------------------------------------------------------------------
		[id(49), helpstring("method ClearFileActionComment")] HRESULT ClearFileActionComment(
			[in] long nFileID, [in] long nActionID);

		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To set the specified file to skipped status for the specified action. 
		//			If bRemovePreviousSkipped is VARIANT_FALSE the SkippedFileTable will only
		//			update the FAMSessionID in an existing record, if VARIANT_TRUE then any record in the
		//			skipped table will be replaced with a new record.
		//			If vbAllowQueuedStatusOverride is VARIANT_TRUE and the QueuedActionStatusChange table
		//			has a pending change for the file, that change will be applied. If
		//			vbAllowQueuedStatusOverride is VARIANT_FALSE, the QueuedActionStatusChange will be
		//			ignored and the status will be set to skipped.
		[id(50), helpstring("method SetFileStatusToSkipped")] HRESULT SetFileStatusToSkipped(
			[in] long nFileID, [in] BSTR bstrAction, [in] VARIANT_BOOL bRemovePreviousSkipped,
			[in] VARIANT_BOOL vbAllowQueuedStatusOverride);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To set all files which match the specified query to the specified status
		//			for the specified action.
		// ARGS:	bstrQuery -		The select query which selects the FAMFile.ID
		//			bstrToAction -	The action to set the new status for
		//			eaNewStatus -	The status to set for the action (ignored if bstrFromAction
		//							is specified)
		//			bstrFromAction - The action to copy the status from for the specified file
		//			pRandomCondition - If NULL will just be ignored, if not NULL then the files
		//							   will only have their status modified if pRandomCondition
		//							   returns TRUE
		// REQUIRE: If bstrFromAction is specified, the bstrQueryFrom query must include the column name
		//			the status is to be copied from.
		[id(51), helpstring("method ModifyActionStatusForSelection")] HRESULT ModifyActionStatusForSelection(
			[in] IFAMFileSelector* pFileSelector, [in] BSTR bstrToAction, [in] EActionStatus eaNewStatus,
			[in] BSTR bstrFromAction, [out,retval] long* pnNumRecordsModified);

		// -----------------------------------------------------------------------------------------------
		// Methods related to file tagging
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get a map of tag names to tag descriptions
		[id(52), helpstring("method GetTags")] HRESULT GetTags([out, retval] IStrToStrMap** ppTags);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get a collection of tag names
		[id(53), helpstring("method GetTagNames")] HRESULT GetTagNames(
			[out, retval] IVariantVector** ppvecTagName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return VARIANT_TRUE if there are any tags in the tags table and VARIANT_FALSE
		//			if there are no tags in the tags table
		[id(54), helpstring("method HasTags")] HRESULT HasTags(VARIANT_BOOL* pbVal);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To add the specified tag to the specified file. If the file already contains
		//			the specified tag this method will do nothing.
		// REQUIRE: bstrTagName is not NULL or empty string AND bstrTagName exists in the Tag table
		[id(55), helpstring("method TagFile")] HRESULT TagFile([in] long nFileID, [in] BSTR bstrTagName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To remove the specified tag from the specified file.  If the file does not contain
		//			the specified tag this method will do nothing.
		// REQUIRE: bstrTagName is not NULL or empty string AND bstrTagName exists in the Tag table
		[id(56), helpstring("method UntagFile")] HRESULT UntagFile([in] long nFileID, [in] BSTR bstrTagName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To toggle the specified tag for the specified file. If the file does not
		//			currently contain the specified tag then the tag will be applied, if the file
		//			contains the tag it will be removed.
		// REQUIRE: bstrTagName is not NULL or empty string AND bstrTagName exists in the Tag table
		[id(57), helpstring("method ToggleTagOnFile")] HRESULT ToggleTagOnFile([in] long nFileID,
			[in] BSTR bstrTagName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To add a new tag to the Tag table with the specified description.
		// REQUIRE: bstrTagName is not NULL or empty string
		//			If vbFailIfExist == VARIANT_TRUE also requires that bstrTagName does not
		//			already exist.
		[id(58), helpstring("method AddTag")] HRESULT AddTag([in] BSTR bstrTagName,
			[in] BSTR bstrTagDescription, [in] VARIANT_BOOL vbFailIfExist);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To remove the specified tag from the Tag table. If bstrTagName does not exist
		//			in the Tag table then the Tag table will remain unchanged.
		// NOTE:	This will also remove the tag from files containing it.
		// REQUIRE: bstrTagName is not NULL or empty string.
		[id(59), helpstring("method DeleteTag")] HRESULT DeleteTag([in] BSTR bstrTagName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To change the name and/or description of an existing tag. If bstrNewTagNam is
		//			NULL or empty string then only the description will be changed,	otherwise both
		//			name and description will be changed.
		// REQUIRE: bstrOldTagName is not NULL or empty string AND bstrOldTagName is in the Tag table
		[id(60), helpstring("method ModifyTag")] HRESULT ModifyTag([in] BSTR bstrOldTagName,
			[in] BSTR bstrNewTagName, [in] BSTR bstrNewTagDescription);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get a list of FileIDs that contain the specified tags.  If vbAndOperation
		//			is VARIANT_TRUE then the files returned will contain all specified tags,
		//			if vbAndOperation is VARIANT_FALSE then the files returned will contain
		//			at least one of the specified tags.
		[id(61), helpstring("method GetFilesWithTags")] HRESULT GetFilesWithTags([in] IVariantVector* pvecTagNames,
			[in] VARIANT_BOOL vbAndOperation, [out, retval] IVariantVector** ppvecFileIDs);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get a list of all tags for a specific file
		[id(62), helpstring("method GetTagsOnFile")] HRESULT GetTagsOnFile([in] long nFileID,
			[out, retval] IVariantVector** ppTagNames);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get whether dynamic tag creation is allowed or not.
		[id(63), helpstring("method AllowDynamicTagCreation")] HRESULT AllowDynamicTagCreation(
			[out, retval] VARIANT_BOOL* pvbVal);
		// -----------------------------------------------------------------------------------------------
		// id(64) Removed unused SetStatusForFilesWithTags

		// -----------------------------------------------------------------------------------------------
		// Methods related to file priority
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return a collection of the file priorities string representations.
		//			Note, in order to map the string to its priority value add 1 to the
		//			strings index value in the vector (i.e. ppvecPriorities[0] has a
		//			priority value of 1, and ppvecPriorities[i] has a priority value of
		//			i+1 - so if ppvecPriorities[0] = "Low" then "Low" corresponds to
		//			priority 1.
		[id(65), helpstring("method GetPriorities")] HRESULT GetPriorities(
			[out, retval] IVariantVector** ppvecPriorities);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To convert the EFilePriority value to a string.
		[id(66), helpstring("method AsPriorityString")] HRESULT AsPriorityString(
			[in] EFilePriority ePriority, [out, retval] BSTR* pbstrPriority);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To convert the priority string to its EFilePriority value.
		[id(67), helpstring("method AsEFilePriority")] HRESULT AsEFilePriority(
			[in] BSTR bstrPriority, [out, retval] EFilePriority* pePriority);

		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To execute the specified command query and return the number of affected rows
		//			(NOTE: This query should not return any results i.e. a SELECT query)
		[id(68), helpstring("method ExecuteCommandQuery")] HRESULT ExecuteCommandQuery(
			[in] BSTR bstrQuery, [out, retval] long* pnRecordsAffected);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To set the priority of all files found by the query strSelectQuery to the specified
		//			priority and return the number of records that were modified.
		//			If pRandomCondition == NULL then all files returned by the query will be modified,
		//			if pRandomComdition != __nullptr then before each file is modified the condition
		//			will be checked and the file will only be modified if the condition returns true.
		[id(69), helpstring("method SetPriorityForFiles")] HRESULT SetPriorityForFiles([in] BSTR strSelectQuery,
			[in] EFilePriority eNewPriority, [in] IRandomMathCondition* pRandomCondition, [out,retval] long* pnNumRecordsModified);
		
		// -----------------------------------------------------------------------------------------------
		// Methods related to UserCounters
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To add a new user counter to the UserCreatedCounter table.  Sets the initial
		//			value for the counter to nInitialValue.
		[id(70), helpstring("method AddUserCounter")] HRESULT AddUserCounter([in] BSTR bstrCounterName,
			[in] LONGLONG llInitialValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To remove the specified counter from the UserCreatedCounter table.  If
		//			bstrCounterName is not found in the database an exception will be thrown.
		[id(71), helpstring("method RemoveUserCounter")] HRESULT RemoveUserCounter(
			[in] BSTR bstrCounterName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To rename the specified counter in the UserCreatedCounterTable.  If bstrCounterName
		//			is not found in the database an exception will be thrown.
		[id(72), helpstring("method RenameUserCounter")] HRESULT RenameUserCounter(
			[in] BSTR bstrCounterName, [in] BSTR bstrNewCounterName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To set the value for the specified counter.  If bstrCounterName is not found
		//			in the database an exception will be thrown.
		[id(73), helpstring("method SetUserCounterValue")] HRESULT SetUserCounterValue(
			[in] BSTR bstrCounterName, [in] LONGLONG llNewValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get the value for the specified counter. If bstrCounterName is not found
		//			in the database an exception will be thrown.
		[id(74), helpstring("method GetUserCounterValue")] HRESULT GetUserCounterValue(
			[in] BSTR bstrCounterName, [out, retval] LONGLONG* pllValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return a collection of all user counters names.
		[id(75), helpstring("method GetUserCounterNames")] HRESULT GetUserCounterNames(
			[out, retval] IVariantVector** ppvecNames);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return a collection of all user counter names and values.
		[id(76), helpstring("method GetUserCounterNamesAndValues")] HRESULT GetUserCounterNamesAndValues(
			[out, retval] IStrToStrMap** ppmapUserCounters);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To check if the specified counter exists in the database
		[id(77), helpstring("method IsUserCounterValid")] HRESULT IsUserCounterValid(
			[in] BSTR bstrCounterName, [out, retval] VARIANT_BOOL* pvbCounterValid);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To add the specified offset value to the specified counter and return the
		//			new counter value.  If bstrCounterName is not found in the database an
		//			exception will be thrown.
		[id(78), helpstring("method OffsetUserCounter")] HRESULT OffsetUserCounter(
			[in] BSTR bstrCounterName, [in] LONGLONG llOffsetValue, [out, retval] LONGLONG*pllNewValue); 

		// -----------------------------------------------------------------------------------------------
		// Methods related to storing FAMSession information
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To record the start time for the current FAM session
		[id(81), helpstring("method RecordFAMSessionStart")] HRESULT RecordFAMSessionStart(
			[in] BSTR bstrFPSFileName, [in] BSTR bstrActionName, [in] VARIANT_BOOL vbQueuing,
			[in] VARIANT_BOOL vbProcessing);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To record the stop time for the current FAM session
		[id(82), helpstring("method RecordFAMSessionStop")] HRESULT RecordFAMSessionStop();

		// -----------------------------------------------------------------------------------------------
		// Methods related to storing input event history
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To record a new input event entry for the specified process ID.
		// NOTE: This method is intentionally not threadsafe for performance reasons.
		[id(83), helpstring("method RecordInputEvent")] HRESULT RecordInputEvent(
			[in] BSTR bstrTimeStamp, [in] long nActionID, [in] long nEventCount,
			[in] long nProcessID);
		// PURPOSE: To return a map containing the Login users and a string that is "Yes" if there 
		//			is a password set for the user or "No" if no password is set
		[id(84), helpstring("method GetLoginUsers")] HRESULT GetLoginUsers(
			[out, retval] IStrToStrMap**  ppUsers);
		// PURPOSE: To add the given user to the Login table
		[id(85), helpstring("method AddLoginUser")] HRESULT AddLoginUser([in] BSTR bstrUserName);
		// PURPOSE: To remove the given user from the Login table
		[id(86), helpstring("method RemoveLoginUser")] HRESULT RemoveLoginUser([in] BSTR bstrUserName);
		// PURPOSE: To rename the given user in the Login table
		[id(87), helpstring("method RenameLoginUser")] HRESULT RenameLoginUser(
			[in] BSTR bstrUserNameToRename, [in] BSTR bstrNewUserName);
		// PURPOSE: To clear the password for the given user in the Login table
		[id(88), helpstring("method ClearLoginUserPassword")] HRESULT ClearLoginUserPassword(
			[in] BSTR bstrUserName);

		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets whether actions should automatically be created in the database when 
		// file processing starts.
		[id(89), helpstring("method GetAutoCreateActions")] HRESULT GetAutoCreateActions(
			[out, retval] VARIANT_BOOL* pvbValue);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: If the action exists in the database, does nothing; if the action does not 
		// exist and the AutoCreateActions setting is on, creates the action; if the action does 
		// not exist and the AutoCreateActions setting is off, throws an exception.
		[id(90), helpstring("method AutoCreateAction")] HRESULT AutoCreateAction(
			[in] BSTR bstrActionName, [out, retval] long* plId);

		//-----------------------------------------------------------------------------------------
		// PURPOSE: To get whether user authentication should be skipped for the current machine
		// when running as a service.
		[id(91), helpstring("method CanSkipAuthenticationOnThisMachine")] HRESULT
			CanSkipAuthenticationOnThisMachine([out, retval] VARIANT_BOOL* pvbSkipAuthentication);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To retrieve the IFileRecord* for a file in the database with the specified
		//			name. Returns NULL if such a record does not exist.
		[id(92), helpstring("method GetFileRecord")] HRESULT GetFileRecord([in] BSTR bstrFile,
			[in] BSTR bstrActionName, [out, retval] IFileRecord** ppFileRecord);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the specified file to processing status for the specified action. 
		//			This call includes all tasks that go along with marking a file as processing
		//			such as attempting to auto-revert locked files, recording appropriate entries in
		//			the FAST table and adding an appropriate entry to the locked file table.
		[id(93), helpstring("method SetFileStatusToProcessing")] HRESULT SetFileStatusToProcessing(
			[in] long nFileId, [in] long nActionID);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To get the connection retry settings associated with the database. 
		[id(94), helpstring("method GetConnectionRetrySettings")] HRESULT GetConnectionRetrySettings(
			[out] long* pnNumberOfRetries, [out] double* pdRetryTimeout);
		//-----------------------------------------------------------------------------------------
		[id(95), helpstring("method CloseAllDBConnections")] HRESULT CloseAllDBConnections();
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Updates the currently connected database to the latest schema.
		[id(96), helpstring("method UpgradeToCurrentSchema")] HRESULT UpgradeToCurrentSchema(
			[in] IProgressStatus* pProgressStatus);
		//-----------------------------------------------------------------------------------------

		// PURPOSE: To rename the file in whose file record is passed in to the given name or path in
		//			in the database
		[id(97), helpstring("method RenameFile")] HRESULT RenameFile([in] IFileRecord* pFileRecord,
			[in] BSTR bstrNewName);

		//-----------------------------------------------------------------------------------------
		// PURPOSE: To get the list of DB info settings
		[propget, id(98), helpstring("property DBInfoSettings")] HRESULT DBInfoSettings(
			[out, retval] IStrToStrMap** ppSettings);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the DB info settings, returns a count of rows that were updated
		// NOTE: The method will not validate the setting name, if the setting
		// name does not exist, it will just be ignored. Also, the count that is returned
		// does not include the update of the LastDBInfoChange time stamp. The time stamp
		// is only set if at least 1 item in the list of settings is updated.
		[id(99), helpstring("method SetDBInfoSettings")] HRESULT SetDBInfoSettings(
			[in] IStrToStrMap* pSettings, [out, retval] long* plNumUpdatedRows);

		// -----------------------------------------------------------------------------------------------
		// Methods related to auto-resetting of files stuck in processing
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To add a new record to the ActiveFAM table associated with the current FAMSession.
		// A thread is started to update the LastPingTime at a regular interval.
		[id(100), helpstring("method RegisterActiveFAM")] HRESULT RegisterActiveFAM();
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To remove the record for in the ActiveFAM table and stop the thread updating
		//			the LastPingTime
		[id(101), helpstring("method UnregisterActiveFAM")] HRESULT UnregisterActiveFAM();
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: Records information regarding an attempted FTP event to the FTPEventHistory table.
		[id(102), helpstring("method RecordFTPEvent")] HRESULT RecordFTPEvent([in] long nFileId,
			[in] long lActionID, [in] VARIANT_BOOL vbQueueing, [in] EFTPAction eFTPAction,
			[in] BSTR bstrServerAddress, [in] BSTR bstrUserName, [in] BSTR bstrArg1,
			[in] BSTR bstrArg2, [in] long nRetries, [in] BSTR bstrException);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To create a new database in the currently set DatabaseServer with the name 
		//			bstrNewDBName with the schema as of the ID Shield / FLEX Index 8.0 release.
		// REQUIRES: DatabaseServer property must be set to a valid database server.
		[id(103), helpstring("method CreateNew80DB")] HRESULT CreateNew80DB([in] BSTR bstrNewDBName);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To recalculate statistics for all actions from the FileActionStatus table.
		// REQUIRES: No active processing on the database.
		[id(104), helpstring("method RecalculateStatistics")] HRESULT RecalculateStatistics();
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To return VARIANT_TRUE if any FAM is active or VARIANT_FALSE if no FAM is active.
		[id(105), helpstring("method IsAnyFAMActive")] HRESULT IsAnyFAMActive(
			[out, retval]  VARIANT_BOOL* pvbFAMIsActive);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Indicates whether retries will be attempted per the CommandTimeout DBInfo setting if a
		// query times out. Default is VARIANT_TRUE so that in cases where the FAMDBAdmin has locked tables
		// for a long period of time, processing can eventually resume without error. For any uses where
		// there is a legitimate reason queries may time out on its own RetryOnTimeout should be set to
		// VARIANT_FALSE.
		[propget, id(106), helpstring("property RetryOnTimeout")] HRESULT RetryOnTimeout([out, retval] VARIANT_BOOL* pVal);
		[propput, id(106), helpstring("property RetryOnTimeout")] HRESULT RetryOnTimeout([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets and sets database connection string properties that should override or be used
		// in additional to the default connection string properties.
		[propput, id(107), helpstring("property AdvancedConnectionStringProperties")]
			HRESULT AdvancedConnectionStringProperties([in] BSTR newVal);		
		[propget, id(107), helpstring("property AdvancedConnectionStringProperties")]
			HRESULT AdvancedConnectionStringProperties([out, retval] BSTR* pVal);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To take an EActionStatus and return the corresponding name
		[id(108), helpstring("method AsStatusName")] HRESULT AsStatusName(
			[in] EActionStatus eaStatus, [out, retval] BSTR* bstrStatusName);
		//-----------------------------------------------------------------------------------------
		// RETURNS: VARIANT_TRUE to indicate the database is currently connected, otherwise
		//			VARIANT_FAlSE
		[propget, id(109), helpstring("property IsConnected")] HRESULT IsConnected(
			[out, retval] VARIANT_BOOL* pbIsConnected);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Displays a dialog that allows the user to select which server/database to login
		//			to or, optionally, create.
		// ARGS:	bstrPrompt- The title bar text for the dialog.
		//			bAllowCreation- Whether the dialog should allow the user the option to create a
		//				new database.
		//			bRequireAdminLogin- Whether admin credentials are required before connected.
		// RETURNS: Whether a database was selected and successfully connected to.		
		[id(110), helpstring("method ShowSelectDB")] HRESULT ShowSelectDB([in] BSTR bstrPrompt,
			[in] VARIANT_BOOL bAllowCreation, [in] VARIANT_BOOL bRequireAdminLogin, 
			[out,retval] VARIANT_BOOL* pbConnected);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Obtains the overall file count. If not using Oracle syntax and the user has
		//			permission to query system view, the system views will be used to get the count
		//			fast rather than having to iterate all files.
		// ARGS:	bUseOracleSyntax- Whether Oracle syntax should be used to obtain the file count.
		// RETURNS: The file count.
		[id(111)] HRESULT GetFileCount(VARIANT_BOOL bUseOracleSyntax, [out,retval] LONGLONG* pnFileCount);
		//-----------------------------------------------------------------------------------------
		// RETURNS: The connection string used to connect based on the current database server,
		//			name and advanced connection string properties.
		// NOTE:	Throws an exception if the database server and name have not been specified.
		[propget, id(112), helpstring("property ConnectionString")]
			HRESULT ConnectionString([out, retval] BSTR* pbstrConnectionString);
		//-----------------------------------------------------------------------------------------
		// RETURNS: VARIANT_TRUE if the whether the user has entered valid admin credentials.
		[propget, id(113), helpstring("property LoggedInAsAdmin")]
			HRESULT LoggedInAsAdmin([out, retval] VARIANT_BOOL* pbLoggedInAsAdmin);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Determines whether a specified feature is enabled using the current credentials.
		// RETURNS: VARIANT_TRUE if the feature is available with the current credentials,
		//			VARIANT_TRUE if it is not.
		[id(114), helpstring("method IsFeatureEnabled")] HRESULT IsFeatureEnabled(
			[in] BSTR bstrFeatureName, [out, retval] VARIANT_BOOL* pbFeatureIsEnabled);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Creates an independent connection to the same DB pConnectionSource is connected
		//			to. The connection inherits the same credentials pConnectionSource is using.
		[id(115), helpstring("method DuplicateConnection")] HRESULT DuplicateConnection(
			[in] IFileProcessingDB *pConnectionSource);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Creates the work item group record for the nFileID, nActionID, stringizedTask and
		//			nNumberOfWorkItems and returns the WorkItemGroupID in pnWorkItemGroupID
		//			If a record already exists for the nFileID, nActionID, and stringizedTask the
		//			and the nNumberOfWorkItems matches the found record the  WorkItemGroupID for the
		//			found record will be returned. 
		[id(116), helpstring("method CreateWorkItemGroup")] HRESULT CreateWorkItemGroup(
			[in] long nFileID, [in] long nActionID, [in] BSTR stringizedTask, [in] long nNumberOfWorkItems,
			[in] BSTR bstrRunningTaskDescription, [out, retval] long *pnWorkItemGroupID);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Adds the work items in pWorkItems to the WorkItem table with the WorkItemGroupID
		// NOTE:	The WorkItem records in the pWorkItems vector are not required to have the 
		//			FileName property set (it will not be used)
		[id(117), helpstring("method AddWorkItems")] HRESULT AddWorkItems(
			[in] long nWorkItemGroupID, [in] IIUnknownVector *pWorkItems);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the work items associated with the work group ID
		//			nCount records will be returned starting at nStartPos, if there not that number
		//			of records after that start position only the number of records remaining will e returned
		// NOTE:	The FileName property for all returned WorkItems in ppWorkItems will be set 
		//			to the current FileName in the database for the FileID in the WorkItemGroup record.
		[id(118), helpstring("method GetWorkItemsForGroup")] HRESULT GetWorkItemsForGroup(
			[in] long nWorkItemGroupID, [in] long nStartPos, [in] long nCount, [out, retval] IIUnknownVector** ppWorkItems); 
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the status of the work item group with the nWorkItemGroupID
		//			The counts of the status for each of the work group items will be returned
		//			in pWorkGroupStatus
		[id(119), helpstring("method GetWorkItemGroupStatus")] HRESULT GetWorkItemGroupStatus (
			[in] long nWorkItemGroupID, [out] WorkItemGroupStatus *pWorkGroupStatus,
			[out, retval] EWorkItemStatus *pStatus);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return a workitem for the nActionID. If vbRestrictToFAMSession is
		//			VARIANT_FALSE the workitem returned will be the next one to be processed for
		//			the nActionID regardless of the FAMSession, but if vbRestrictToFAMSession is
		//			VARIANT_TRUE only work items for the nActionID and the curring FAM session will
		//			be returned
		// NOTE:	The FileName property in the WorkItem returned will be set to the current FileName
		//			in the database for the FileID for the WorkItemGroup
		[id(120), helpstring("method GetWorkItemToProcess")] HRESULT GetWorkItemToProcess([in] BSTR bstrActionName,
			[in] VARIANT_BOOL vbRestrictToFAMSession, [out, retval] IWorkItemRecord **ppWorkItem);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the status of the nWorkItemID to failed
		[id(121), helpstring("method NotifyWorkItemFailed")] HRESULT NotifyWorkItemFailed(
			[in] long nWorkItemID, [in] BSTR stringizedException);

		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the status of the nWorkItemID to Completed
		[id(122), helpstring("method NotifyWorkItemCompleted")] HRESULT NotifyWorkItemCompleted(
			[in] long nWorkItemID);		
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the number of workItems in pnNumberOfWorkItems and the stringizedTask 
		//			for the WorkItemGroupID
		[id(123), helpstring("method GetWorkGroupData")] HRESULT GetWorkGroupData([in] long WorkItemGroupID,
			[out] long *pnNumberOfWorkItems, [out, retval] BSTR *pstringizedTask);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To save the strWorkItemOutput in the WorkItem table as a string.
		[id(124), helpstring("method SaveWorkItemOutput")] HRESULT SaveWorkItemOutput([in] long WorkItemID, [in] BSTR strWorkItemOutput);

		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the WorkItemGroupID if it exists for a work item group that matches
		//			the other fields if there is no match the return value *pnWorkItemGroupID = 0
		// NOTE:	The nNumberOfWorkItems is compared to the both the NumberOfWorkItems field in
		//			the WorkItemGroup table and the actual number of work items in the WorkItem
		//			table for a found work group
		[id(125), helpstring("method FindWorkItemGroup")] HRESULT FindWorkItemGroup(
			[in] long nFileID, [in] long nActionID, [in] BSTR stringizedTask, [in] long nNumberOfWorkItems,
			[in] BSTR bstrRunningTaskDescription, [out, retval] long *pnWorkItemGroupID); 
		[id(126), helpstring("method SaveWorkItemBinaryOutput")] HRESULT SaveWorkItemBinaryOutput(
			[in] long WorkItemID, [in] IUnknown *pBinaryOutput);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Returns the name of all file sets currently defined in this instance.
		// NOTE:	File sets are not currently persisted to the database. Rather, they exist only
		//			in the current FileProcesingDB instance.
		[id(127), helpstring("method GetFileSets")] HRESULT GetFileSets(
			[out, retval] IVariantVector **pvecFileSetNames);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Creates a file set of the specified name consisting of the specified file ids.
		// NOTE:	File sets are not currently persisted to the database. Rather, they exist only
		//			in the current FileProcesingDB instance. If a file set already existed by this
		//			name, it will be replaced.
		[id(128), helpstring("method AddFileSet")] HRESULT AddFileSet([in] BSTR bstrFileSetName,
			[in] IVariantVector *pvecIDs);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Returns file IDs in the specified file set.
		// NOTE:	File sets are not currently persisted to the database. Rather, they exist only
		//			in the current FileProcesingDB instance.
		[id(129), helpstring("method GetFileSetFileIDs")] HRESULT GetFileSetFileIDs(
			[in] BSTR bstrFileSetName, [out, retval] IVariantVector **ppvecFileIDs);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Returns file names in the specified file set.
		// NOTE:	File sets are not currently persisted to the database. Rather, they exist only
		//			in the current FileProcesingDB instance.
		[id(130), helpstring("method GetFileSetFileNames")] HRESULT GetFileSetFileNames(
			[in] BSTR bstrFileSetName, [out, retval] IVariantVector **ppvecFileNames);
		//-----------------------------------------------------------------------------------------
		// PROMISE:	Gets the specified file for processing. The status for the file will be set to
		//			'R' in the specified action before this method returns.
		//			if strFromState is an empty string any state except 'R' will be changed to 'R'
		//			otherwise only the state that is specified 'R' is not allowed.
		[id(131), helpstring("method GetFileToProcess")] HRESULT GetFileToProcess([in] long nFileID,
			[in] BSTR strAction, [in] BSTR bstrFromState, [out, retval] IFileRecord** ppFileRecord);
		//-----------------------------------------------------------------------------------------
		// PROMISE:	Applies a new EActionStatus as the fallback status to return to if this
		//			currently processing file is cancelled before processing completes.
		// REQUIRE: The specified file must currently be locked for processing by the current
		//			process.
		[id(132), helpstring("method SetFallbackStatus")] HRESULT SetFallbackStatus(
			[in] IFileRecord* pFileRecord, [in] EActionStatus eaFallbackStatus);
		//-----------------------------------------------------------------------------------------
		// PROMISE: Gets up to nMaxWorkItemsToReturn from the database that have a minimum 
		//			priority of eMinPriority for the given nActionID will be returned in ppWorkItems
		//			if vbRestrictToFAMSession is VARIANT_TRUE only work items that are in a work
		//			item group that is being processed in the current instance.
		// NOTE:	Work items associated with a work item group with an empty string as the UPI
		//			will not be included. This is to limit processing of work items that are not 
		//			associated with a Work item group that is currently active.
		[id(133), helpstring("method GetWorkItemsToProcess")] HRESULT GetWorkItemsToProcess([in] BSTR bstrActionName,
			[in] VARIANT_BOOL vbRestrictToFAMSession, 
			[in] long nMaxWorkItemsToReturn,
			[in] EFilePriority eMinPriority,
			[out, retval] IIUnknownVector **ppWorkItems);
		//-----------------------------------------------------------------------------------------
		// PROMISE: Sets the work item with nWorkItemID to pending if its previous status is processing
		[id(134), helpstring("method SetWorkItemToPending")] HRESULT SetWorkItemToPending([in] long nWorkItemID);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To return the failed work items for the group
		[id(135), helpstring("method GetFailedWorkItemsForGroup")] HRESULT GetFailedWorkItemsForGroup(
			[in] long nWorkItemGroupID,  [out, retval] IIUnknownVector** ppWorkItems);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To apply the specified metadata field value to the specified file. If the file already
		//			has a value for the field, it will be overwritten.
		// REQUIRE: bstrMetadataFieldName exists in the MetadataField table.
		[id(136), helpstring("method SetMetadataFieldValue")] HRESULT SetMetadataFieldValue([in] long nFileID,
			[in] BSTR bstrMetadataFieldName, [in] BSTR bstrMetadataFieldValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get the specified metadata field value for the specified file.
		[id(137), helpstring("method GetMetadataFieldValue")] HRESULT GetMetadataFieldValue([in] long nFileID,
			[in] BSTR bstrMetadataFieldName, [out, retval] BSTR *pbstrMetadataFieldValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To add a new metadata field to the MetadataField table.
		// REQUIRE: bstrMetadataFieldName is not NULL or empty string
		[id(138), helpstring("method AddMetadataField")] HRESULT AddMetadataField([in] BSTR bstrMetadataFieldName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To remove the specified metadata field from the MetadataField table.
		//			If bstrMetadataFieldName does not exist	in the MetadataField table then the MetadataField
		//			table will remain unchanged.
		// NOTE:	This will also remove any values for this field from the FileMetadataValue table.
		// REQUIRE: bstrMetadataFieldName is not NULL or empty string.
		[id(139), helpstring("method DeleteMetadataField")] HRESULT DeleteMetadataField(
			[in] BSTR bstrMetadataFieldName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To change the name of an existing metadata field.
		// REQUIRE: bstrOldMetadataFieldName is not NULL or empty string AND bstrOldMetadataFieldName
		//			is in the MetadataField table.
		[id(140), helpstring("method RenameMetadataField")] HRESULT RenameMetadataField(
			[in] BSTR bstrOldMetadataFieldName,	[in] BSTR bstrNewMetadataFieldName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To get a collection of metadata field names
		[id(141), helpstring("method GetMetadataFieldNames")] HRESULT GetMetadataFieldNames(
			[out, retval] IVariantVector** ppvecMetadataFieldNames);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets a connection string for the last configured DB server, database, and advanced
		// connection string properties in this process.
		// NOTE: The connection string may be for a database that has not actually been used. The
		// connection string is based only on the properties of an IFileProcessingDB instance that have
		// been set, not based on a connection  that has actually been opened. Thus, for example, if we are
		// running within a RunFPSFile instance with the /ingoreDB flag, even though the FAM instance will
		// not have connected to a database, the database info will still have been loaded from the FPS file
		// and that is what will be used here.
		[id(142), helpstring("method GetLastConnectionStringConfiguredThisProcess ")]
			HRESULT GetLastConnectionStringConfiguredThisProcess([out, retval] BSTR *pbstrConnectionString);
		// -----------------------------------------------------------------------------------------------
		// Gets the ActiveFAMID for any currently active FAM; otherwise, 0.
		[propget, id(143), helpstring("property ActiveFAMID")] HRESULT ActiveFAMID([out, retval] long* pnActiveFAMID);
		// -----------------------------------------------------------------------------------------------
		// Gets the FAMSessionID for the current FAM session; 0 if there is no current FAMSession.
		[propget, id(144), helpstring("property FAMSessionID")] HRESULT FAMSessionID([out, retval] long* pnFAMSessionID);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: Adds a row to the FileTaskSession table for a task that has been started. The timestamp
		//			and duration columns will be NULL at this point. It is assumed that the specified
		//			bstrTaskClassGuid already exists in the TaskClass table.
		// RETURNS: The ID of the added FileTaskSession row.
		[id(145), helpstring("methods StartFileTaskSession")] HRESULT StartFileTaskSession(
			[in] BSTR bstrTaskClassGuid, [in] long nFileID, [in] long nActionID, [out, retval] long *pnFileTaskSessionID);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To execute the specified command query and return the number of affected rows
		// AND a long long value of a named column.
		//			(NOTE: This query should not return any results i.e. a SELECT query, meant for insert
		//			 where a single value is returned typically using OUTPUT INSERTED.ID)
		[id(146), helpstring("method ExecuteCommandReturnLongLongResult")] HRESULT ExecuteCommandReturnLongLongResult(
			[in] BSTR bstrQuery, [in] BSTR bstrResultColumnName, [out] long long* pResult, [out, retval] long* pnRecordsAffected);
		// -----------------------------------------------------------------------------------------------
		[id(147), helpstring("method GetFileNameFromFileID")]
		HRESULT GetFileNameFromFileID( [in] long fileID, [out, retval] BSTR* pbstrFileName );
		// PURPOSE: To return an IUnknownVector that contains objects of type 
		//			Extract.FileActionManager.Database.FAMDBRuleExecutionCounter for each counter that
		//			is in the SecureCounter table
		// -----------------------------------------------------------------------------------------------
		// Get a vector of the secure counters currently defined in the database. If vbRefresh ==
		// VARIANT_TRUE, the counter status will be re-validated and re-queried; otherwise the any
		// previously retrieved counter list will be used.
		[id(148), helpstring("method GetSecureCounters")] HRESULT GetSecureCounters(
			[in] VARIANT_BOOL vbRefresh, [out, retval] IIUnknownVector** ppSecureCounters);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return the name for the counter with an ID of nCounterID
		[id(149), helpstring("method GetSecureCounterName")] HRESULT GetSecureCounterName(
			[in] long nCounterID, [out, retval] BSTR *pstrCounterName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To apply an upgrade code that is a hex string that contains a ByteStream 
		//			encrypted with the FAM Password that contains the following:
		//			DatabaseGUID - DatabaseGUID that is stored in the DatabaseID
		//			ServerName - Name of the server the code is from 
		//			DatabaseName - Name of the database the code is from
		//			DatabaserCeatedDate - creation date of the database
		//			DatabaseRestoredDate - restore date of the database - if database has not been restored
		//								this will equal the DatabaseCreatedDate
		//			LastUpdatedDate - Last time an update code was applied
		//			TimeCodeGenerated - For informational purposes - could be used to expire a code
		//			UserName - For informational purposes - User that generated the code
		//			MachineName - For informational purposes - Machine that generated the code
		//			NumberOfOperations - number of updates included in the code if this is negative the code
		//				is an unlock code and the list of counters will only be CounterID and Value for
		//				each counter that was in the request code that was used to generate the unlock code
		//			List of Counters:
		//				CounterID - Id of counter to update
		//				CounterName - Name of counter if counter ID < 100 the counter it is not included
		//				Operation - 0 - None, 1 - Create, 2 - Set, 3 - Increment, 4 - Decrement, 5 - Delete, 6 - Rename
		//				Value - Amount used to set or update the counter.
		//			Return value pbstrResult will have a line for each update that was performed and what was done
		[id(150), helpstring("method ApplySecureCounterUpdateCode")] HRESULT ApplySecureCounterUpdateCode(
			[in] BSTR strUpdateCode, [out, retval] BSTR *pbstrResult);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return the current value of the counter with counter id nCounterID
		[id(151), helpstring("method GetSecureCounterValue")] HRESULT GetSecureCounterValue(
			[in] long nCounterID, [out, retval] long* pnCounterValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To decrement the value of the counter given by nCounterID by the decrementAmount
		//			and return the new value of the counter. If there are not enough counts an exception 
		//			is thrown.
		[id(152), helpstring("method DecrementSecureCounter")] HRESULT DecrementSecureCounter(
			[in] long nCounterID, [in] long decrementAmount, [out, retval] long* pnCounterValue);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To check the consistency of the Secure counter tables 
		[id(153), helpstring("method SecureCounterConsistencyCheck")] HRESULT SecureCounterConsistencyCheck(
			[out, retval] VARIANT_BOOL* pvbValid);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: To return a update request code that is an encrypted ByteStream that contains 
		//			the following:
		//			DatabaseGUID - DatabaseGUID that is stored in the DatabaseID
		//			ServerName - Name of the server the code is from 
		//			DatabaseName - Name of the database the code is from
		//			DatabaseCreatedDate - creation date of the database
		//			DatabaseRestoredDate - restore date of the database - if database has not been restored
		//								this will equal the DatabaseCreatedDate
		//			LastUpdatedDate - Last time an update code was applied
		//			NumberOfCounters - number of counters defined in SecureCounters if the counters are locked
		//				when this code is generated the value will be -(number of counters) - this will be negative 
		//				if the counters are in a corrupt state
		//			List of counters
		//				CounterID
		//				CounterName - Name of counter only included if counter id > 100
		//				CounterValue - Value of counter when Request code generated.
		[id(154), helpstring("method GetCounterUpdateRequestCode")] HRESULT GetCounterUpdateRequestCode(
			[out, retval] BSTR* pstrUpdateRequestCode);
		// -----------------------------------------------------------------------------------------------
		// The string representation of the GUID ID for the FAM DB.
		[propget, id(155), helpstring("method DatabaseID")] HRESULT DatabaseID(
			[out, retval] BSTR* pbstrDatabaseID);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: Gets the name of the database server this instance last connected to. This is the
        //			same server name used by the encrypted database ID, not the user-entered server
        //			(i.e., will never be "(local)").
		[propget, id(156), helpstring("method ConnectedDatabaseServer")] HRESULT ConnectedDatabaseServer(
			[out, retval] BSTR* pbstrServerName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: Gets the name of the database name this instance last connected to. 
		[propget, id(157), helpstring("method ConnectedDatabaseName")] HRESULT ConnectedDatabaseName(
			[out, retval] BSTR* pbstrDatabaseName);
		// -----------------------------------------------------------------------------------------------
		// PURPOSE: Sets the alert level and alert multiple for the specified secure counter.
		[id(158), helpstring("method SetSecureCounterAlertLevel")] HRESULT SetSecureCounterAlertLevel(
			[in] long nCounterID, [in] long nAlertLevel, [in] long nAlertMultiple);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To add the file to the database without making it pending for any action. This call
		//			does not expect the file to exist at the specified location. Because of this, the
		//			file size and page count must be supplied by the caller.
		// RETURNS: The ID that has been associated with the file.
		[id(159), helpstring("method AddFileNoQueue")] HRESULT AddFileNoQueue([in] BSTR strFile,
			[in] long long llFileSize, [in] LONG lPageCount,  [in] EFilePriority ePriority,
			[in] long nWorkflowID, [out, retval] long* pnID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To add data to the Pagination table indicating the source of all pages for the
		//			newly generated bstrOutputFile.
		//			pSourcePageInfo is expected to be an IUnknownVector with the same number of items
		//			as there are pages in nOutputFileID. Each item in the vector is expected to be a
		//			IStringPair instance where the StringKey is the filename of the document the
		//			respective page came from and the StringValue is the string representation of the
		//			page number.
		[id(160), helpstring("method AddPaginationHistory")] HRESULT AddPaginationHistory(
			[in] long nOutputFileID, [in] IIUnknownVector* pSourcePageInfo,
			IIUnknownVector* pDeletedSourcePageInfo, [in] long nFileTaskSessionID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Applies the specified durations to the specified FileTaskSession row. The
		//			DateTimeStamp will also be applied.
		[id(161), helpstring("methods UpdateFileTaskSession")] HRESULT UpdateFileTaskSession(
			[in] long nFileTaskSessionID, [in] double dDuration, [in] double dOverheadTime, [in] double dActivityTime);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Adds a new workflow to the database
		[id(162), helpstring("methods AddWorkflow")] HRESULT AddWorkflow(
			[in] BSTR bstrName, [in] EWorkflowType eType, [out, retval] long* pnID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Deletes the specified workflow from the database
		[id(163), helpstring("methods DeleteWorkflow")] HRESULT DeleteWorkflow(
			[in] long nID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the properties that define a workflow.
		[id(164), helpstring("methods GetWorkflowDefinition")] HRESULT GetWorkflowDefinition(
			[in] long nID, [out, retval] IWorkflowDefinition** ppWorkflowDefinition);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Sets the properties that define the workflow.
		[id(165), helpstring("methods SetWorkflowDefinition")] HRESULT SetWorkflowDefinition(
			[in] IWorkflowDefinition* pWorkflowDefinition);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets all of the workflow names with IDs
		[id(166), helpstring("methods GetWorkflows")] HRESULT GetWorkflows([out, retval] IStrToStrMap ** pmapWorkFlowNameToID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the actions associated with a workflow. Each action will be represented as a
		//			VariantVector with three values each:
		//			1: long ID
		//			2: BSTR Name
		//			3: VARIANT_BOOL MainSequence
		[id(167), helpstring("methods GetWorkflowActions")] HRESULT GetWorkflowActions([in] long nID,
			[out, retval] IIUnknownVector ** pvecActions);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Sets the actions associated with a workflow. Each action specified should be a
		//			VariantVector with 2 values each:
		//			1: BSTR Name
		//			2: VARIANT_BOOL MainSequence
		[id(168), helpstring("methods SetWorkflowActions")] HRESULT SetWorkflowActions([in] long nID,
			[in] IIUnknownVector* pActionList);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Sets the currently active workflow
		[propget, id(169), helpstring("property ActiveWorkflow ")] HRESULT ActiveWorkflow([out, retval] BSTR* pbstrWorkflowName);
		[propput, id(169), helpstring("property ActiveWorkflow ")] HRESULT ActiveWorkflow([in] BSTR bstrWorkflowName);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the ID of the currently active action
		[propget, id(170), helpstring("property ActiveActionID ")] HRESULT ActiveActionID([out, retval] long* pnActionID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To return a IActionStistics pointer that contains the current stats for the specified action
		//			in all workflows.
		//			NOTE: This may count the same file twice if a file has been added to more than one workflow.
		[id(171), helpstring("method GetStatsAllWorkflows")] HRESULT GetStatsAllWorkflows([in] BSTR bstrActionName,
			[in] VARIANT_BOOL vbForceUpdate, [out, retval] IActionStatistics** pStats);
		// -----------------------------------------------------------------------------------------------
		// PROMISE:	To return a StringToLong map of all actions in the DB independent of workflow and their
		//			corresponding IDs in the database. The IDs will be instances that are not associated with
		//			any workflow.
		[id(172), helpstring("method GetAllActions")] HRESULT GetAllActions(
			[out, retval] IStrToStrMap ** pmapActionNameToID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the status of a file in a workflow where status is defined as:
		//			Whereas X = the primary actions in a workflow (excludes and actions that do not logically
		//				fall between StartAction and EndAction
		//			Processing = (EndAction <> Failed/Skipped) and (any action X is either pending or processing)
		//			Failed = (EndAction <> Complete) and (any action X is failed)
		//			Unattempted = (EndAction <> Complete) and (no X actions  are pending / processing)
		//			Completed = (EndAction = Compete) and (no action X is pending or processing)
		[id(173), helpstring("method GetWorkflowStatus")] HRESULT GetWorkflowStatus(
			[in] long nFileID, [out, retval] EActionStatus* peaStatus);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the status of all files in a workflow where status is defined as:
		//			Whereas X = the primary actions in a workflow (excludes and actions that do not logically
		//				fall between StartAction and EndAction
		//			Processing = (EndAction <> Failed/Skipped) and (any action X is either pending or processing)
		//			Failed = (EndAction <> Complete) and (any action X is failed)
		//			Unattempted = (EndAction <> Complete) and (no X actions  are pending / processing)
		//			Completed = (EndAction = Compete) and (no action X is pending or processing)
		[id(174), helpstring("method GetAggregateWorkflowStatus")] HRESULT GetAggregateWorkflowStatus(
			[out] long *pnUnattempted, [out] long *pnProcessing, [out] long *pnCompleted, [out] long *pnFailed);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Logs into the database with the specified username and password.
		//			If the username and/or password are not valid, the call will throw and exception.
		// NOTE:	This method cannot be used to login with a user that does not have a password set.
		[id(175), helpstring("method LoginUser")] HRESULT LoginUser([in] BSTR bstrUserName, [in]BSTR bstrPassword);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets whether the currently processing FAM is configured to be running all workflows in
		//			a database with workflows defined.
		[propget, id(176), helpstring("method RunningAllWorkflows")] HRESULT RunningAllWorkflows([out, retval] VARIANT_BOOL *pRunningAllWorkflows);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Returns the ID for the specified workflow name.
		//			If the specified workflow name is blank, the ID of the current workflow will be returned.
		//			If the specified workflow name is blank and no workflow is active, -1 will be returned.
		//			If the specified workflow name is not found (case-insensitive) an exception will be thrown.
		[id(177), helpstring("method GetWorkflowID")] HRESULT GetWorkflowID([in] BSTR bstrWorkflowName,
			[out, retval] long *pnID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Indicates whether the specified file is in the specified workflow.
		//			If the specified workflow ID is -1, the current workflow will be tested.
		//			If there are no workflows defined, the result will indicate whether the file ID is present in the DB.
		[id(178), helpstring("method IsFileInWorkflow")] HRESULT IsFileInWorkflow([in] long nFileID,
			[in] long nWorkflowID, [out, retval] VARIANT_BOOL *pbIsInWorkflow);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets whether the FAM database has any workflows defined.
		[propget, id(179), helpstring("method UsingWorkflows")] HRESULT UsingWorkflows([out, retval] VARIANT_BOOL *pbUsingWorkflows);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the workflow name associated with the ActionID
		[id(180), helpstring("method GetWorkflowNameFromActionID")] HRESULT GetWorkflowNameFromActionID(
			[in] long nActionID, [out, retval] BSTR* pbstrWorkflowName);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: To return the ActionID for the given action name in the specified workflow.
		//			-1 will be returned if the action does not exist in the specified workflow.
		[id(181), helpstring("method GetActionIDForWorkflow")] HRESULT GetActionIDForWorkflow([in] BSTR bstrActionName, [in] long nWorkflowID,
			[out, retval]long* pnActionID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets or Sets the Number of connection retries - once the put method has been used
		//			the number of retries is can only be changed using these methods
		[propput, id(182), helpstring("property NumberOfConnectionRetries")] HRESULT NumberOfConnectionRetries([in] long nNewVal);
		[propget, id(182), helpstring("property NumberOfConnectionRetries")] HRESULT NumberOfConnectionRetries([out,retval] long *pnVal);
		// PROMISE: Gets or Sets the retry timeout - once the put method has been used
		//			the timeout is can only be changed using these methods
		//			the value is the number of seconds t
		[propput, id(183), helpstring("property ConnectionRetryTimeout")] HRESULT ConnectionRetryTimeout([in] long nNewVal);
		[propget, id(183), helpstring("property ConnectionRetryTimeout")] HRESULT ConnectionRetryTimeout([out, retval] long *pnVal);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Set a new password for the specified user
		// NOTE:	Call will fail if not currently logged in as admin.
		[id(184), helpstring("method SetNewPassword")] HRESULT SetNewPassword([in] BSTR bstrUserName, [out, retval] VARIANT_BOOL* pbSuccess);
		// PROMISE: Moves the files selected by the query that are in the SourceWorkflow to the DestWorkflow
		//			nSourceWorkflowID = 0 it will be to only move files that have a workflow assigned
		//			nSourceWorkflowID = -1 will be to only move files that have not been assigned to any workflow
		[id(185), helpstring("method MoveFilesToWorkflowFromQuery")] HRESULT MoveFilesToWorkflowFromQuery(
			[in] BSTR bstrQuery, [in] long nSourceWorkflowID, [in] long nDestWorkflowID,
			[out, retval] long *pnCount);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the value of first attribute matching the specified attribute path in the
		//			specified attribute set for the specified file or blank if the specified attribute
		//			does not exist in the database.
		[id(186), helpstring("method GetAttributeValue")] HRESULT GetAttributeValue(
			[in] BSTR bstrSourceDocName, [in] BSTR bstrAttributeSetName, [in] BSTR bstrAttributePath,
			[out, retval] BSTR* pbstrValue);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Indicates whether the specified filename exists in the active workflow/database.
		//			If the specified workflow ID is -1, the current workflow will be tested.
		//			If there are no workflows defined, the result will indicate whether the file ID is present in the DB.
		[id(187), helpstring("method IsFileNameInWorkflow")] HRESULT IsFileNameInWorkflow([in] BSTR bstrFileName,
			[in] long nWorkflowID, [out, retval] VARIANT_BOOL *pbIsInWorkflow);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Saves the JSON settings for a web verification application of the specified type to
		//			the specified workflow.
		//			NOTE: Saving with bstrSettings erases previously saved settings.
		[id(188), helpstring("method SaveWebAppSettings")] HRESULT SaveWebAppSettings(
			[in] long nWorkflowID, [in] BSTR bstrType, [in] BSTR bstrSettings);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Loads JSON settings for a web verification application of the specified type for the
		//			specified workflow.
		[id(189), helpstring("method LoadWebAppSettings")] HRESULT LoadWebAppSettings(
			[in] long nWorkflowID, [in] BSTR bstrType, [out, retval] BSTR *pbstrSettings);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Creates a new MLModel record with the specified name. Does nothing if the name already exists.
		[id(190), helpstring("method DefineNewMLModel")] HRESULT DefineNewMLModel([in] BSTR strModelName,
			[out, retval] long* pnID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Deletes the MLModel record with the specified name
		[id(191), helpstring("method DeleteMLModel")] HRESULT DeleteMLModel([in] BSTR strModelName);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Deletes the MLModel record with the specified name
		[id(192), helpstring("method GetMLModels")] HRESULT GetMLModels([out,retval] IStrToStrMap ** pmapModelNameToID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Opens a session for a web application (Recorded in FAMSession table, same as FAM sessions.
		[id(193), helpstring("method RecordWebSessionStart")] HRESULT RecordWebSessionStart( 
			[in] BSTR bstrType, [in] BSTR bstrLoginId, [in] BSTR bstrIpAddress, [in] BSTR bstrUser);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Gets the names of all users with active FAM session for the specified action.
		[id(194), helpstring("method GetActiveUsers")] HRESULT GetActiveUsers(
			[in] BSTR bstrAction, [out, retval] IVariantVector** ppvecUserNames);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Intended to clean up a FAM session that is know to have been unexpectedly abandoned.
		//			Removes the row from the ActiveFAM table and resets the status of any files that
		//			had been processing, but does not properly close out the FAMSession table row.
		[id(195), helpstring("method AbortFAMSession")] HRESULT AbortFAMSession([in] long nFAMSessionID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Marks a file as deleted in the specified workflow;
		[id(196), helpstring("method MarkFileDeleted")] HRESULT MarkFileDeleted([in] long nFileID, [in] long nWorkflowID);
		// -----------------------------------------------------------------------------------------------
		// PROMISE: Returns the status of all files in the workflow via a delimited string where each file
		//			status is delimited by a comma, and for each file the ID (on left) is delimted from the
		//			single character status (R, C, F, U on right) by a colon.
		[id(197), helpstring("method GetWorkflowStatusAllFiles")] HRESULT GetWorkflowStatusAllFiles(
			[out, retval] BSTR *pbstrStatusListing);
		// -----------------------------------------------------------------------------------------------
		// Resumes an existing FAMSession by setting appropriate instance members and returns data for the last still-processing file
		// associated with the session, if there is one. Returns VARIANT_TRUE if there was a file still processing. Throws an exception if 
		// there is no registered FAMSession for nFAMSessionID
		[id(198), helpstring("method ResumeWebSession")] HRESULT ResumeWebSession(
			[in] long nFAMSessionID, [out] long* pnFileTaskSessionID, [out] long* pnOpenFileID, [out, retval] VARIANT_BOOL* pbIsFileOpen);
		// -----------------------------------------------------------------------------------------------
		// Suspends an existing FAMSession by resetting appropriate instance members so that this instance is no longer associated with a FAMSession
		[id(199), helpstring("method SuspendWebSession")] HRESULT SuspendWebSession();
		// -----------------------------------------------------------------------------------------------
		// Checks to see if a particular session ID is still open (doesn't have a Stop time)
		[id(200), helpstring("method IsFAMSessionOpen")] HRESULT IsFAMSessionOpen([in] long nFAMSessionID, [out, retval] VARIANT_BOOL* pbIsFAMSessionOpen);
		// -----------------------------------------------------------------------------------------------
		// Returns the number of skipped files for the user
		[id(201), helpstring("method GetNumberSkippedForUser")] HRESULT GetNumberSkippedForUser([in] BSTR bstrUserName, [in] long nActionID,
			[in] VARIANT_BOOL bRevertTimedOutFAMs, [out, retval] long* pnFilesSkipped);
		// -----------------------------------------------------------------------------------------------
		// Change the password of a user
		[id(202), helpstring("method ChangePassword")] HRESULT ChangePassword([in] BSTR userName, BSTR oldPassword, [in] BSTR newPassword);
	};

	[
		object,
		uuid(18A41FE5-1D07-4af1-91F1-809988312CFE),
		dual,
		helpstring("IProductSpecificDBMgr Interface"),
		pointer_default(unique)
	]
	interface IProductSpecificDBMgr : IDispatch
	{
		// PROMISE: To create the required tables and relationships for the product that is 
		//			implementing this interface.  
		// ARGS:	bOnlyTables- VARIANT_TRUE if only tables are to be added (and not stored procedures, etc).
		// ARGS:	bAddUserTables- VARIANT_TRUE if user tables need to be added.
		[id(1), helpstring("method AddProductSpecificSchema")] HRESULT AddProductSpecificSchema(
			[in] IFileProcessingDB* pDB, [in] VARIANT_BOOL bOnlyTables, [in] VARIANT_BOOL bAddUserTables);

		// PROMISE: To remove any relationships and tables that were added in a call to AddProductSpecificSchema
		// ARGS:	bOnlyTables- VARIANT_TRUE if only tables are to be added (and not stored procedures, etc).
		// ARGS:	bAddUserTables- VARIANT_TRUE if user tables need to be retained.
		// RETURNS: pbSchemaExists- VARIANT_TRUE if the schema elements existed or VARIANT_FALSE if they did not.
		[id(2), helpstring("method RemoveProductSpecificSchema")] HRESULT RemoveProductSpecificSchema(
			[in] IFileProcessingDB* pDB, [in] VARIANT_BOOL bOnlyTables, [in] VARIANT_BOOL bRetainUserTables,
			[out, retval] VARIANT_BOOL* pbSchemaExists);

		// PROMISE: Ensures the product database schema is up-to-date.
		[id(3), helpstring("method ValidateSchema")] HRESULT ValidateSchema([in] IFileProcessingDB* pDB);

		// PROMISE: Returns an IVariantVector of the names of all rows in the DBInfo table
		// this product-specific database manages or has managed since FAM DB version 23.
		[id(4), helpstring("method GetDBInfoRows")] HRESULT GetDBInfoRows([out, retval] IVariantVector** ppDBInfoRows);

		// PROMISE: Returns an IVariantVector of the names of all database tables this
		// product-specific database manages or has managed since FAM DB version 23.
		[id(5), helpstring("method GetTables")] HRESULT GetTables([out, retval] IVariantVector** ppTables);

		// PROMISE: Updates (or provides a relative time estimation for the product-specific database
		//			for an update) on the specified connection to the latest version corresponding to
		//			the specified FAM DB version.
		// ARGS:	pDB - The database being acted upon.
		//			pConnection - The database connection to use so that aborted updates can be
		//				backed out by the caller.
		//			nFAMDBSchemaVersion - The update should correspond to this FAM DB version.
		//			pnProdSchemaVersion - The value passed in specifies the starting product-specific
		//				DB version, the value passed back represents the updated version. If the value
		//				passed in is 0, the current product-specific version will be used as the
		//				starting point.
		//			pnNumSteps - If a non-NULL pointer is passed in, rather than actually performing
		//				the update, pnNumSteps will instead be assigned the number of progress steps
		//				that should be assigned to the update. Suggested values for implementers are:
		//				3 = An O(1) operation such as creating a new table.
		//				10 = A relatively simple O(n) DB query to run relative to the number of files
		//					in the database.
		//			pProgressStatus - The progress status object to update during the operation (can
		//				be NULL if not progress updates are needed.
		[id(6), helpstring("method UpdateSchemaForFAMDBVersion")] HRESULT UpdateSchemaForFAMDBVersion(
			[in] IFileProcessingDB* pDB, [in] _Connection* pConnection, [in] long nFAMDBSchemaVersion,
			[in, out] long* pnProdSchemaVersion, [in, out] long* pnNumSteps,
			[in] IProgressStatus* pProgressStatus);

		// PROMISE: To create the required tables and relationships for the product that is 
		//			implementing this interface as of the schema that existed for the IDS/Flex 8.0
		//			release.
		[id(7), helpstring("method AddProductSpecificSchema80")] HRESULT AddProductSpecificSchema80(
			[in] IFileProcessingDB* pDB);
	};

	[
		object,
		uuid(1377A637-5EA4-45F9-9827-AAD1E6FC55F7),
		dual,
		nonextensible,
		helpstring("IFileSupplierData Interface"),
		pointer_default(unique)
	]
	interface IFileSupplierData : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return IObjectWithDescription object that contains
		//			- IFileSupplier
		//			- Description
		//			- Enabled flag
		//			to provide files to be processed by the defined tasks
		[propget, id(1), helpstring("property FileSupplier")] HRESULT FileSupplier([out, retval] IObjectWithDescription** pValue);
		[propput, id(1), helpstring("property FileSupplier")] HRESULT FileSupplier([in] IObjectWithDescription* newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return boolean flag indicating that processing of the files should be 
		//			forced
		[propget, id(2), helpstring("property ForceProcessing")] HRESULT ForceProcessing([out, retval] VARIANT_BOOL* pbValue);
		[propput, id(2), helpstring("property ForceProcessing")] HRESULT ForceProcessing([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return enumeration indicating the processing state of the File Supplier
		//			{ Inactive, Active, Paused, Stopped, Done }
		[propget, id(3), helpstring("property FileSupplierStatus")] HRESULT FileSupplierStatus(
			[out, retval] EFileSupplierStatus* pVal);
		[propput, id(3), helpstring("property FileSupplierStatus")] HRESULT FileSupplierStatus(
			[in] EFileSupplierStatus newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To get/set the priority that files will be assigned by the FileSupplier
		[propget, id(4), helpstring("property Priority")] HRESULT Priority(
			[out, retval] EFilePriority* pVal);
		[propput, id(4), helpstring("property Priority")] HRESULT Priority(
			[in] EFilePriority newVal);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(2E5B30DD-670D-4D00-8AAF-6B521DCA39D8),
		dual,
		nonextensible,
		helpstring("IFileActionMgmtRole Interface"),
		pointer_default(unique)
	]
	interface IFileActionMgmtRole : IDispatch{
		//-----------------------------------------------------------------------------------------
		// NOTE:	All the methods below (with the exception of Clear) require that the action 
		//			management role be enabled, and all data needed by the action management role
		//			has been specified.  If these two conditions are not met, an exception will
		//			be raised.
		//-----------------------------------------------------------------------------------------
		[id(1), helpstring("method Start")] HRESULT Start([in] IFileProcessingDB* pDB, 
			[in] long lActionId, [in] BSTR bstrAction, [in] long hWndOfUI, 
			[in] IFAMTagManager* pTagManager, IRoleNotifyFAM* pRoleNotifyFAM,
			[in] BSTR bstrFpsFileName);
		[id(2), helpstring("method Stop")] HRESULT Stop(void);
		[id(3), helpstring("method Pause")] HRESULT Pause(void);
		[id(4), helpstring("method Resume")] HRESULT Resume(void);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To enable/disable the particular action mgmt role in the file action manager
		//			The state of this property is directly correlated with the state of the
		//			corresponding checkbox on the action tab in the UI
		[propget, id(5), helpstring("property Enabled")] HRESULT Enabled([out, retval] VARIANT_BOOL* pVal);
		[propput, id(5), helpstring("property Enabled")] HRESULT Enabled([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To reset the data members of the action mgmt role and restore it to a clean,
		//			non-dirty state
		[id(6), helpstring("method Clear")] HRESULT Clear(void);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return com exception if it can not be saved or run
		[id(7), helpstring("method ValidateStatus")] HRESULT ValidateStatus(void);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(DD34F02C-251E-4CAF-B519-91A91FBD79CB),
		dual,
		nonextensible,
		helpstring("IFileSupplyingMgmtRole Interface"),
		pointer_default(unique)
	]
	interface IFileSupplyingMgmtRole : IDispatch{

		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the collection of IFileSupplier items as contained in FileSupplierData
		//			- IFileSupplierData
		//			  * IObjectWithDescription
		//			    + IFileSupplier object
		//			    + Description
		//			    + Enabled flag
		//			  * Force Processing flag
		//			  * File Supplier Status enumeration
		[propget, id(1), helpstring("property FileSuppliers")] HRESULT FileSuppliers([out, retval] IIUnknownVector** pVal);
		[propput, id(1), helpstring("property FileSuppliers")] HRESULT FileSuppliers([in] IIUnknownVector * newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return IFAMCondition object that determines whether SourceDocName should
		//			be processed by the defined tasks
		[propget, id(2), helpstring("property FAMCondition")] HRESULT FAMCondition([out, retval] IObjectWithDescription** pVal);
		[propput, id(2), helpstring("property FAMCondition")] HRESULT FAMCondition([in] IObjectWithDescription * newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the state of the dirty flag.
		// NOTE:	This method is required here because at this time the FileSupplyingMgmtRole object
		//			does not know how to read itself out of the FPS file stream.  Since the stream
		//			is read from/written to at the outer scope, the outer scope needs to be able to
		//			set the state of the dirty flag.
		[id(3), helpstring("method SetDirty")] HRESULT SetDirty([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To get the number of files that have been supplied and number of supplying errors
		[id(4), helpstring("method GetSupplyingCounts")] HRESULT GetSupplyingCounts([out] long* plNumSupplied,
			[out] long* plNumSupplyingErrors);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Specifies whether an attempt will be made to check the page count when files are queued.
		[propget, id(5), helpstring("property SkipPageCount")] HRESULT SkipPageCount([out, retval] VARIANT_BOOL *pVal);
		[propput, id(5), helpstring("property SkipPageCount")] HRESULT SkipPageCount([in] VARIANT_BOOL newVal);
	};

	[
		object,
		uuid(F3F26D6F-716B-41ae-BF30-9A3BA5F92F93),
		dual,
		nonextensible,
		helpstring("IFileProcessingMgmtRole Interface"),
		pointer_default(unique)
	]
	interface IFileProcessingMgmtRole : IAccessRequired
	{

		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the collection of IFileProcessingTask items 
		[propget, id(1), helpstring("property FileProcessors")] HRESULT FileProcessors([out, retval] IIUnknownVector** pVal);
		[propput, id(1), helpstring("property FileProcessors")] HRESULT FileProcessors([in] IIUnknownVector* newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the number of threads
		[propget, id(2), helpstring("property NumThreads")] HRESULT NumThreads([out, retval] long* pVal);
		[propput, id(2), helpstring("property NumThreads")] HRESULT NumThreads([in] long newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the state of the dirty flag.
		// NOTE:	This method is required here because at this time the FileProcessingMgmtRole object
		//			does not know how to read itself out of the FPS file stream.  Since the stream
		//			is read from/written to at the outer scope, the outer scope needs to be able to
		//			set the state of the dirty flag.
		[id(3), helpstring("method SetDirty")] HRESULT SetDirty(VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[id(4), helpstring("method SetRecordMgr")] HRESULT SetRecordMgr(void* pRecordMgr);
		//-----------------------------------------------------------------------------------------
		[propget, id(5), helpstring("property OkToStopWhenQueueIsEmpty")] HRESULT OkToStopWhenQueueIsEmpty([out, retval] VARIANT_BOOL* pVal);
		[propput, id(5), helpstring("property OkToStopWhenQueueIsEmpty")] HRESULT OkToStopWhenQueueIsEmpty([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(6), helpstring("property KeepProcessingAsAdded")] HRESULT KeepProcessingAsAdded([out, retval] VARIANT_BOOL* pVal);
		[propput, id(6), helpstring("property KeepProcessingAsAdded")] HRESULT KeepProcessingAsAdded([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return True if exception information should be appended to a user-specified 
		//			log file if one of the regular tasks (see FileProcessingTasks) fails.
		[propget, id(7), helpstring("property LogErrorDetails")] HRESULT LogErrorDetails([out, retval] VARIANT_BOOL* pVal);
		[propput, id(7), helpstring("property LogErrorDetails")] HRESULT LogErrorDetails([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the name of a user-specified log file to which exception information 
		//			will be appended if one of the regular tasks (see FileProcessingTasks) fails.
		//			Standard document tags (<SourceDocName>, etc.) are supported.
		[propget, id(8), helpstring("property ErrorLogName")] HRESULT ErrorLogName([out, retval] BSTR* pVal);
		[propput, id(8), helpstring("property ErrorLogName")] HRESULT ErrorLogName([in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return True if a separate task should be executed if one of the regular tasks 
		//			(see FileProcessingTasks) fails.  The setting is stored in the Enabled field 
		//			associated with the ErrorTask ObjectWithDescription.
		[propget, id(9), helpstring("property ExecuteErrorTask")] HRESULT ExecuteErrorTask([out, retval] VARIANT_BOOL* pVal);
		[propput, id(9), helpstring("property ExecuteErrorTask")] HRESULT ExecuteErrorTask([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return IFileProcessingTask object that will be executed if one of the tasks 
		//			(see FileProcessingTasks) fails.
		[propget, id(10), helpstring("property ErrorTask")] HRESULT ErrorTask([out, retval] IObjectWithDescription** pVal);
		[propput, id(10), helpstring("property ErrorTask")] HRESULT ErrorTask([in] IObjectWithDescription * newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the processing management role to process files that are in skipped status
		[propget, id(11), helpstring("property ProcessSkippedFiles")] HRESULT ProcessSkippedFiles(
			[out, retval] VARIANT_BOOL* pbVal);
		[propput, id(11), helpstring("property ProcessSkippedFiles")] HRESULT ProcessSkippedFiles(
			[in] VARIANT_BOOL bNewVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To set the scope of the file processing when processing skipped files
		//			(when ProcessSkippedFiles == VARIANT_TRUE). If VARIANT_TRUE	all skipped files
		//			for the current action will be processed, if VARIANT_FALSE only files skipped
		//			by the current user for the current action will be processed.
		[propget, id(12), helpstring("property SkippedForAnyUser")] HRESULT SkippedForAnyUser(
			[out, retval] VARIANT_BOOL* pbVal);
		[propput, id(12), helpstring("property SkippedForAnyUser")] HRESULT SkippedForAnyUser(
			[in] VARIANT_BOOL bNewVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(13), helpstring("property ProcessingSchedule")] HRESULT ProcessingSchedule(
			[out, retval] IVariantVector** ppHoursSchedule);
		[propput, id(13), helpstring("property ProcessingSchedule")] HRESULT ProcessingSchedule(
			[in] IVariantVector* pHoursSchedule);
		//-----------------------------------------------------------------------------------------
		[propget, id(14), helpstring("property LimitProcessingToSchedule")] 
			HRESULT LimitProcessingToSchedule([out, retval] VARIANT_BOOL* pbVal);
		[propput, id(14), helpstring("property LimitProcessingToSchedule")] 
			HRESULT LimitProcessingToSchedule([in] VARIANT_BOOL bVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To process only the specified file regardless of what other files are queued in
		//			the database and what their file priorities are.
		[id(15), helpstring("method ProcessSingleFile")] HRESULT ProcessSingleFile(
			[in] IFileRecord* pFileRecord, [in] IFileProcessingDB* pFPDB, [in] IFAMTagManager* pFAMTagManager);
		//-----------------------------------------------------------------------------------------
		[propget, id(16), helpstring("property FPDB")] HRESULT FPDB([out, retval] IFileProcessingDB** ppFPDB);
		[propput, id(16), helpstring("property FPDB")] HRESULT FPDB([in] IFileProcessingDB* pFPDB);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Specifies whether an email is to be sent upon a processing failure.
		[propget, id(17), helpstring("property SendErrorEmail")] HRESULT SendErrorEmail([out, retval] VARIANT_BOOL* pVal);
		[propput, id(17), helpstring("property SendErrorEmail")] HRESULT SendErrorEmail([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: The IErrorEmailTask to use to send an email upon processing failure. May be NULL
		//			if not currently configured to send an email upon failure.
		[propget, id(18), helpstring("property ErrorEmailTask")] HRESULT ErrorEmailTask([out, retval] IErrorEmailTask** pVal);
		[propput, id(18), helpstring("property ErrorEmailTask")] HRESULT ErrorEmailTask([in] IErrorEmailTask * newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Indicates whether processing has completed.
		// NOTE:	This method flag is set to false as processing is started and only indicates true
		//			after at least one file has processed. If the process is configured to keep processing as
		//			files are queued, but no files ever are, this flag will remain false.
		[propget, id(19), helpstring("property HasProcessingCompleted")] HRESULT HasProcessingCompleted([out, retval] VARIANT_BOOL* pVal);
		// PROMISE: Gets whether any of the processing Displays a UI
		[propget, id(20), helpstring("property ProcessingDisplaysUI")] HRESULT ProcessingDisplaysUI([out, retval] VARIANT_BOOL* pProcessingDisplaysUI);
	};

	[
		object,
		uuid(274ED4F6-1CDB-43CB-B73F-C0A8B6737369),
		dual,
		nonextensible,
		helpstring("IFileRequestHandler Interface"),
		pointer_default(unique)
	]
	interface IFileRequestHandler : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Requests that the current instance lock the specified file for processing and
		//			add it to the current process's set of files to process.
		// ARGS:	nFileID- The file to checkout
		//			vbAllowQueuedStatusOverride - Whether QueuedActionStatusChange records
		//				should be honored when this file comes out of processing.
		//			pPrevStatus- The status of the file in the current action before being checked out.
		//			pSucceeded- VARIANT_TRUE if the file was able to be checked out (or the current
		//				process already had it checked out). VARIANT_FALSE if another process already
		//				had the file checked out.
		[id(1), helpstring("method CheckoutForProcessing")] HRESULT CheckoutForProcessing(
			[in] long nFileID, [in] VARIANT_BOOL vbAllowQueuedStatusOverride,
			[out] EActionStatus* pPrevStatus, [out, retval] VARIANT_BOOL* pSucceeded);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Moves the specified file to the front of the current process's internal queue
		//			of files checked out for processing to ensure it is the next file that starts
		//			processing.
		// ARGS:	nFileID- The file to process next.
		//			pSucceeded- VARIANT_TRUE if the file was currently checked out for processing
		//				by the current instance and was able to be moved to the front. VARIANT_FALSE
		//				if the file is either already processing or is not checked out for processing
		//				by the current instance.
		[id(2), helpstring("method MoveToFrontOfProcessingQueue")] HRESULT MoveToFrontOfProcessingQueue(
			[in] long nFileID, [out, retval] VARIANT_BOOL* pSucceeded);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Releases the specified file from the current process's internal queue of files
		//			checked out for processing. The file will be treated as if processing has been
		//			canceled/stopped and returned to the current fallback status (status before lock
		//			by default).
		// ARGS:	nFileID- The file to release.
		//			pSucceeded- VARIANT_TRUE if the file was currently checked out for processing
		//				by the current instance and was able to be released. VARIANT_FALSE if the
		//				file is either already processing or is not checked out for processing by
		//				the current instance.
		[id(3), helpstring("method ReleaseFile")] HRESULT ReleaseFile(
			[in] long nFileID, [out, retval] VARIANT_BOOL* pSucceeded);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Specifies the EActionStatus the specified file will return to if processing is
		// cancelled or the file is released. This will be the status before lock by default.
		[id(4), helpstring("method SetFallbackStatus")] HRESULT SetFallbackStatus(
			[in] long nFileID, [in] EActionStatus eaFallbackStatus,
			[out, retval] VARIANT_BOOL* pSucceeded);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Temporarily prevents new files from being grabbed by the process for
		// processing. Processing threads will block until ResumeProcessingQueue is called.
		[id(5), helpstring("method PauseProcessingQueue")] HRESULT PauseProcessingQueue();
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Restores normal behavior of processing queue.
		[id(6), helpstring("method ResumeProcessingQueue")] HRESULT ResumeProcessingQueue();
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Requests that the current instance grab the next file in the queue for
		//			processing.
		// ARGS:	vbAllowQueuedStatusOverride - Whether QueuedActionStatusChange records
		//				should be honored when this file comes out of processing.
		//			pnFileID- The ID of the file that was checked out or -1 if there was no
		//			available file in the queue.
		[id(7), helpstring("method CheckoutNextFile")] HRESULT CheckoutNextFile(
			[in] VARIANT_BOOL vbAllowQueuedStatusOverride, [out, retval] long* pnFileID);
		//-----------------------------------------------------------------------------------------
		// PROMISE: Returns the ID of the next file checked out for processing that is not yet
		//			actively processing in the FAM. If nAfterFileId is not -1, the ID of any file
		//			after nAfterFileId will be returned; otherwise the first checked out file not
		//			yet processing will be returned. If nAfterFileId is not -1 but the specified
		//			file is not processing, this call will behave as if nAfterFileId is -1.
		//			If no qualifying file is queued for processing, -1 is returned.
		[id(8), helpstring("method GetNextCheckedOutFile")] HRESULT GetNextCheckedOutFile(
			[in] long nAfterFileID, [out, retval] long* pnFileID);
	};

	[
		object,
		uuid(A6A1C6CE-C0A1-4cbb-811A-FD92CD525731),
		dual,
		nonextensible,
		helpstring("IRoleNotifyFAM Interface"),
		pointer_default(unique)
	]
	interface IRoleNotifyFAM : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To be used to notify the FileActionManager that the Processing is complete
		[id(1), helpstring("method NotifyProcessingCompleted")] HRESULT NotifyProcessingCompleted(void);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To be used to notify the FileActionManager that the Supplying is complete
		[id(2), helpstring("method NotifySupplyingCompleted")] HRESULT NotifySupplyingCompleted(void);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To be used to notify the FileActionManager that the Processing is canceling
		[id(3), helpstring("method NotifyProcessingCancelling")] HRESULT NotifyProcessingCancelling();
	};

	[
		object,
		uuid(EE7703EA-F880-45ef-842C-11A6B82DB3EF),
		dual,
		nonextensible,
		helpstring("IFAMTagManager Interface"),
		pointer_default(unique)
	]
	interface IFAMTagManager : IDispatch
	{
		// FPS file directory name
		[propget, id(1), helpstring("property FPSFileDir")] HRESULT FPSFileDir([out, retval] BSTR *strFPSFileDir);
		[propput, id(1), helpstring("property FPSFileDir")] HRESULT FPSFileDir([in] BSTR strFPSFileDir);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To return a string that is equivalent in content to strInput
		// bstrSourceName is the source doc name used in expand <SourceDocName>, it should be passed in as a parameter because
		// different thread will have different source doc name [P13: 3901]
		[id(2), helpstring("method ExpandTags")] HRESULT ExpandTags([in] BSTR bstrInput, [in] BSTR bstrSourceName, [out, retval] BSTR* pbstrOutput);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To return VARIANT_TRUE if there are any invalid or incomplete
		//			tags in strInput, and to return VARIANT_FALSE otherwise.
		// NOTE:	For the sake of this method, a tag name is valid if it is one of
		//			the predefined tags (like <FPSFileDir> etc), or if there is
		//			a key in the INI file in the [ExpandableTags]
		//			section with a non-empty value.
		[id(6), helpstring("method StringContainsInvalidTags")] HRESULT StringContainsInvalidTags([in] BSTR strInput, [out, retval] VARIANT_BOOL* pbValue);
		//-----------------------------------------------------------------------------------------
		// REQUIRE: strInput must contain no tags, or 1 or more well specified
		//			tags.  Poorly specified tags in strInput (such as non-matching
		//			'<' and '>', etc) will cause an exception to be thrown.
		// PROMISE: To return VARIANT_TRUE if there are any tags in the
		//			strInput, regardless of whether they are valid tag names
		[id(7), helpstring("method StringContainsTags")] HRESULT StringContainsTags([in] BSTR strInput, [out, retval] VARIANT_BOOL* pbValue);
		// PROMISE: To return a string that is equivalent in content to strInput
		// bstrSourceName is the source doc name used in expand <SourceDocName>, it should be passed in as a parameter because
		// different thread will have different source doc name [P13: 3901]
		[id(8), helpstring("method ExpandTagsAndFunctions")] HRESULT ExpandTagsAndFunctions(
			[in] BSTR bstrInput, [in] BSTR bstrSourceName, [out, retval] BSTR* pbstrOutput);
		//-----------------------------------------------------------------------------------------
		// FPS file full name
		[propget, id(9), helpstring("property FPSFileName")] HRESULT FPSFileName([out, retval] BSTR *strFPSFileName);
		[propput, id(9), helpstring("property FPSFileName")] HRESULT FPSFileName([in] BSTR strFPSFileName);
		//-----------------------------------------------------------------------------------------
		// IF VARIANT_TRUE, <DatabaseServer>, <DatabaseName> and <DatabaseAction> will be available
		// even if they haven't been defined as a CustomTag.
		[propget, id(10), helpstring("property AlwaysShowDatabaseTags")] HRESULT AlwaysShowDatabaseTags([out, retval] VARIANT_BOOL *pbValue);
		[propput, id(10), helpstring("property AlwaysShowDatabaseTags")] HRESULT AlwaysShowDatabaseTags([in] VARIANT_BOOL bValue);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Verifies that the tag manager has all necessary info to expand tags during processing.
		//			bstrDatabaseServer and bstrDatabaseName refer to the FAM's literally configured
		//			database parameters, not the path tag expansion of those parameters.
		//			If non-null, pbstrWarning will describe any non-critical configurations issues.
		[id(12), helpstring("method ValidateConfiguration")] HRESULT ValidateConfiguration(
			[in] BSTR bstrDatabaseServer, [in] BSTR bstrDatabaseName, [out, retval] BSTR* pbstrWarning);
		// Returns the active context
		[propget, id(13), helpstring("property ActiveContext")] HRESULT ActiveContext([out,retval] BSTR *strActiveContext);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Sets the database server - this may contain tags 
		[propget, id(14), helpstring("property DatabaseServer")] HRESULT DatabaseServer([out, retval] BSTR *strDatabaseServer);
		[propput, id(14), helpstring("property DatabaseServer")] HRESULT DatabaseServer([in] BSTR strDatabaseServer);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Sets the database name - this may contain tags 
		[propget, id(15), helpstring("property DatabaseName")] HRESULT DatabaseName([out, retval] BSTR *strDatabaseName);
		[propput, id(15), helpstring("property DatabaseName")] HRESULT DatabaseName([in] BSTR strDatabaseName);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Sets the Action name
		[propget, id(16), helpstring("property ActionName")] HRESULT ActionName([out, retval] BSTR *strActionName);
		[propput, id(16), helpstring("property ActionName")] HRESULT ActionName([in] BSTR strActionName);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Refreshes context tag info based on current FPSFileDir from ContextTags.sdf.
		[id(17), helpstring("method RefreshContextTags")] HRESULT RefreshContextTags();
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Sets and gets the Current workflow
		[propget, id(18), helpstring("property Workflow")] HRESULT Workflow([out, retval] BSTR *strWorkflow);
		[propput, id(18), helpstring("property Workflow")] HRESULT Workflow([in] BSTR strWorkflow);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Returns a cloned FAMTagManager that has the workflow set to the workflow provided
		[id(19), helpstring("method GetFAMTagManagerWithWorkflow")] HRESULT GetFAMTagManagerWithWorkflow(
			[in] BSTR bstrWorkflow, [out, retval] IFAMTagManager** ppFAMTagManager);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Provides the FileProcessingDB instance that is used to expand $Metadata path
		// tag functions.
		[propget, id(20), helpstring("property FAMDB")] HRESULT FAMDB([out, retval] IFileProcessingDB** ppFAMDB);
		[propput, id(20), helpstring("property FAMDB")] HRESULT FAMDB([in] IFileProcessingDB* pFAMDB);


	};

	[
		object,
		uuid(5F1B8A0D-CA2B-4eb0-9892-5C9D71F81547),
		dual,
		nonextensible,
		helpstring("IFAMDBUtils Interface"),
		pointer_default(unique)
	]
	interface IFAMDBUtils : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To be used to notify the FileActionManager that the Processing is complete
		[id(1), helpstring("method PromptForActionSelection")] HRESULT PromptForActionSelection(
			[in]IFileProcessingDB* pDB, [in] BSTR strTitle, [in] BSTR strPrompt, 
			[in]VARIANT_BOOL vbAllowTags, [out, retval] BSTR* pActionName);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the ProgID of the FAM Database type to be used
		// NOTE: There is a .net type that support Oracle and the cpp type that supports SQL Server
		//		 the type is determined by the registry key:
		//			HKCU\Extract Systems\ReusableComponents\COMComponents\UCLIDFileProcessing\FileProcessingDB\DBManagerType
		[id(2), helpstring("method GetFAMDBProgId")] HRESULT GetFAMDBProgId([out, retval] BSTR *pProgID);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the ProgID of the IDShield Product Specific Database type to be used
		// NOTE: There is a .net type that support Oracle and the cpp type that supports SQL Server
		//		 the type is determined by the registry key:
		//			HKCU\Extract Systems\ReusableComponents\COMComponents\UCLIDFileProcessing\FileProcessingDB\DBManagerType
		[id(3), helpstring("method GetIDShieldDBProgId")] HRESULT GetIDShieldDBProgId([out, retval] BSTR *pProgID);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To return the ProgID of the Data Entry Product Specific Database type to be used
		// NOTE: There is a .net type that support Oracle and the cpp type that supports SQL Server
		//		 the type is determined by the registry key:
		//			HKCU\Extract Systems\ReusableComponents\COMComponents\UCLIDFileProcessing\FileProcessingDB\DBManagerType
		[id(4), helpstring("method GetDataEntryDBProgId")] HRESULT GetDataEntryDBProgId([out, retval] BSTR *pProgID);
	};
	[
		object,
		uuid(1CCBF08F-43B2-4E55-8010-311360670704),
		dual,
		nonextensible,
		helpstring("IFileProcessingTaskExecutor Interface"),
		pointer_default(unique)
	]
	// There are two ways in which FileProcessingTask can be used:
	// 1) To process a single file with a set of processing tasks, call InitProcessClose
	// 2) To process multiple files with a set of processing tasks:
	//		- Call Init
	//		- Call ProcessFile for each file to be processed
	//		- Call Close
	interface IFileProcessingTaskExecutor : IDispatch
	{
		// PROMISE: To accept a given file processing task list, database ptr and tag manager
		//			to use to process files. To subsequently call Init on each of the
		//			file processing tasks
		// ARGS:	pFileProcessingTasks- A Object with Description list of file processing tasks
		//			nActionID- The ID of the action being processed
		//			pDB- The database being acted upon
		//			pFAMTagManager- The tag manager to use when required
		//			pFileRequestHandler- The IFileRequestHandler that can be used
        //			by the tasks to carry out requests for files to be checked out, released or
		//			re-ordered in the queue.
		//			NOTE: pFileRequestHandler is not currently guaranteed to be available in all
		//			execution contexts. The task is responsible for asserting its existence if
		//			needed.
		[id(1), helpstring("method Init")] HRESULT Init([in] IIUnknownVector* pFileProcessingTasks,
			[in] long nActionID, [in] IFileProcessingDB* pDB, [in] IFAMTagManager* pFAMTagManager,
			[in] IFileRequestHandler* pFileRequestHandler);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To process the given file
		// ARGS:	pFileRecord - The file record of the file to process
		//			nActionID - The ID of the action being processed
		//			pProgressStatus- The ProgressStatus object to update
		//			pbSuccessfulCompletion- VARIANT_TRUE if successful; VARIANT_FALSE is indicative of cancellation since
		//				an error should fire an exception
		//			bCancelRequested - VARIANT_TRUE if the user has requested cancellation.  IFileProcessingTaskExecutor
		//				doesn't act upon this flag, but passes it on to the tasks it executes
		// REQUIRED: Init must have been called prior to calling ProcessFile.
		[id(2), helpstring("method ProcessFile")] HRESULT ProcessFile([in] IFileRecord* pFileRecord, 
			[in] long nActionID, [in] IProgressStatus* pProgressStatus,
			[in] VARIANT_BOOL bCancelRequested, [out, retval] EFileProcessingResult* pResult);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To process the given file with one call (separate calls to Init and Close not required)
		// ARGS:	pFileRecord - The file record of the file to process
		//			pFileProcessingTasks- A Object with Description list of file processing tasks
		//			nActionID - The ID of the action being processed
		//			pDB- The database being acted upon
		//			pFAMTagManager- The tag manager to use when required
		//			pFileRequestHandler- The IFileRequestHandler that can be used
        //			by the tasks to carry out requests for files to be checked out, released or
		//			re-ordered in the queue.
		//			NOTE: pFileRequestHandler is not currently guaranteed to be available in all
		//			execution contexts. The task is responsible for asserting its existence if
		//			needed.
		//			pProgressStatus- The ProgressStatus object to update (can be NULL)
		//			bCancelRequested - VARIANT_TRUE if the user has requested cancellation.  IFileProcessingTaskExecutor
		//				doesn't act upon this flag, but passes it on to the tasks it executes
		//			pbSuccessfulCompletion- VARIANT_TRUE if successful; VARIANT_FALSE is indicative of cancellation since
		//				an error should fire an exception
		// REQUIRED: Nothing.
		[id(3), helpstring("method InitProcessClose")] HRESULT InitProcessClose(
			[in] IFileRecord* pFileRecord, [in] IIUnknownVector* pFileProcessingTasks,
			[in] long nActionID, [in] IFileProcessingDB* pDB, [in] IFAMTagManager* pFAMTagManager, 
			[in] IFileRequestHandler* pFileRequestHandler, [in] IProgressStatus* pProgressStatus,
			[in] VARIANT_BOOL bCancelRequested, [out, retval] EFileProcessingResult* pResult);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To call cancel on the currently running task.
		//			Notifies the currently executing task (if there is one) the user has requested for 
		//			processing to stop. It is not required that the active task necessarily abort processing, however.  
		//			Currently the only FileProcessingTask that acts on this request is the RedactionVerificationUI
		// REQUIRED: Nothing. If there is no current task, this call will have no effect
		[id(4), helpstring("method Cancel")] HRESULT Cancel();
		//-----------------------------------------------------------------------------------------
		// PROMISE: To close all file processing tasks
		//			However, the FileProcessingTaskExecutor does maintain the task list until destruction
		//			or the next call to Init or ProcessOneFile
		// REQUIRED: Init must have been called prior to calling ProcessFile.
		[id(5), helpstring("method Close")] HRESULT Close();
		//-----------------------------------------------------------------------------------------
		// PROMISE: To return a IFileProcessingTask pointer to the currently running task.
		//			If no task is currently running, NULL is returned
		// REQUIRED: Nothing. (If the executor has not been initialized GetCurrentTask will return NULL)
		[id(6), helpstring("method GetCurrentTask")] HRESULT GetCurrentTask([out, retval] IFileProcessingTask **ppCurrentTask);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To indicate whether the task executor is currently initialized
		[propget, id(8), helpstring("property IsInitialized")] HRESULT IsInitialized([out, retval] VARIANT_BOOL* pVal);
		//-----------------------------------------------------------------------------------------
		// PROMISE:	To notify a the TaskExecutor that the pending document queue is empty, but
		//			the processing tasks have been configured to remain running until the next
		//			document has been supplied. If the processor will standby until the next
		//			file is supplied it should return VARIANT_TRUE. If the processor wants to
		//			cancel processing, it should return VARIANT_FALSE. If the processor does not
		//			immediately know whether processing should be cancelled right away, it may
		//			block until it does know, and return at that time.
		// NOTE:	This call will be made on a different thread than the other calls, so the
		//			Standby call must be thread-safe.This allows the file processor to block on
		//			the Standby call, but it also means that call to ProcessFile or Close may
		//			come while the Standby call is still occurring. If this happens, the return
		//			value of Standby will be ignored; however, Standby should promptly return
		//			in this case to avoid needlessly keeping a thread alive.
		[id(9), helpstring("method Standby")] HRESULT Standby([out, retval] VARIANT_BOOL* pVal);
		//-----------------------------------------------------------------------------------------
		// PROMISE: To notify the TaskExecutor that following a previous Standby call either
		//			another file has been supplied or processing has been stopped and, therefore,
		//			it can ignore any still blocking Standby calls.
		[id(10), helpstring("method EndStandby")] HRESULT EndStandby();
	};

	[
		object,
		uuid(B43F3C65-BAA5-4AC1-BF47-5B9250F88192),
		dual,
		helpstring("ISetProcessingSchedule Interface"),
		pointer_default(unique)
	]
	interface ISetProcessingSchedule : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To be used to notify the FileActionManager that the Processing is complete
		[id(1), helpstring("method PromptForSchedule")] HRESULT PromptForSchedule(
			[in]IVariantVector* pSchedule, [out, retval] IVariantVector** ppNewSchedule); 
	};

	[
		object,
		uuid(40CEC6E1-1A84-484A-9E3D-AFA736D9327B),
		dual,
		helpstring("IConfigureDBInfoSettings Interface"),
		pointer_default(unique)
	]
	interface IConfigureDBInfoSettings : IDispatch
	{
		// PURPOSE: To prompt the user to modify the DB info settings. Returns VARIANT_TRUE
		// if the settings were updated and VARIANT_FALSE if they were not updated.
		[id(1), helpstring("method PromptForSettings")] HRESULT PromptForSettings(
			[in] IFileProcessingDB* pDBManager, [out, retval] VARIANT_BOOL* pbUpdated);
	};

	[
		object,
		uuid(B0CF1FC4-4E1A-46C5-BED1-1D6D9D730187),
		dual,
		helpstring("ISecureCounterManagement Interface"),
		pointer_default(unique)
	]
	interface ISecureCounterManagement : IDispatch
	{
		// PURPOSE: Displays UI for managing the secure counters in the specified pDB.
		[id(1), helpstring("method ShowUI")] HRESULT ShowUI([in] IFileProcessingDB* pDB, [in] HANDLE owner);
	};

	[
		object,
		uuid(3C96B8AE-BA83-4FEB-8EC9-D060CC33F1AA),
		dual,
		nonextensible,
		pointer_default(unique)
	]
	interface IFAMFileSelector : IDispatch
	{
		// PURPOSE: Displays a dialog to allow configuration of the condition and subset settings.
		// ARGS:	bstrPrompt- Text applied to group box explaining the purpose of the settings.
		//			bstrQueryLabel- The select clause of an SQL query to be displayed above any
		//				query condition edit box.
		// RETURNS:	pbNewSettingsApplied- VARIANT_TRUE if the user pressed OK to accept new
		//				settings, otherwise VARIANT_FALSE.
		[id(1), helpstring("method Configure")] HRESULT Configure(
			[in] IFileProcessingDB *pFAMDB, [in] BSTR bstrPrompt, [in] BSTR bstrQueryLabel,
			[in] VARIANT_BOOL bIgnoreWorkflows, [out, retval] VARIANT_BOOL* pbNewSettingsApplied);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Adds an action status condition to the current settings.
		// ARGS:	pFAMDB- The IFileProcessingDB the condition relates to.
		//			bstrAction- The name of the action the condition relates to.
		//			eStatus- The status files must be in nActionID to meet the condition's criteria.
		[id(2), helpstring("method AddActionStatusCondition")] HRESULT AddActionStatusCondition(
			[in] IFileProcessingDB *pFAMDB, [in] BSTR bstrAction, [in] EActionStatus eStatus);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets colloquial text describing the current settings.
		// RETURNS:	pbstrSummaryString- The colloquial text describing the current settings.
		// ARGS:	The same pFAMDB and bIgnoreWorkflows parameters should be used here as will be
		//			used for BuildQuery so as to be able to display to the user if results will be
		//			limited to a specific workflow.
		[id(3), helpstring("method GetSummaryString")] HRESULT GetSummaryString(
			[in] IFileProcessingDB *pFAMDB, [in] VARIANT_BOOL bIgnoreWorkflows,
			[out, retval] BSTR* pbstrSummaryString);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets whether the instance is currently configured to return all files.
		// RETURNS:	pbSelectingAllFiles- VARIANT_TRUE if currently configured to return all files,
		//				VARIANT_FALSE if there are any conditions of subsets configured.
		[propget, id(4), helpstring("property SelectingAllFiles")] HRESULT SelectingAllFiles(
			[out, retval] VARIANT_BOOL* pbSelectingAllFiles);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Generates an SQL query to select files based on the current settings.
		// ARGS:	pFAMDB- The IFileProcessingDB the query is to be used for.
		//			bstrSelect- The columns the query should select. For example:
		//				"FAMFile.ID, FAMFile.FileName" or "FAMFile.ID, FAMFile.Priority".
		//				NOTE: It can be assumed that the FAMFile table will be included in the query.
		//			bIgnoreWorkflows - if VARIANT_TRUE the returned query doesn't include any workflow
		//				references. if VARIANT_FALSE if workflows are defined the state of the ActiveWorkflow
		//				property on pFAMDB will be used to build the query
		// RETURNS: pbstrQuery- The query to select files based on the current settings.
		[id(5), helpstring("method BuildQuery")] HRESULT BuildQuery(
			[in] IFileProcessingDB *pFAMDB, [in] BSTR bstrSelect, [in] BSTR bstrOrderByClause,
			[in] VARIANT_BOOL bIgnoreWorkflows, [out, retval] BSTR* pbstrQuery);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Resets all configured condition and subset settings.
		[id(6), helpstring("method Reset")] HRESULT Reset();
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Limits the file selected to a subset of those meeting the currently configured
		//			conditions.
		// ARGS:	bRandomSubset- VARIANT_TRUE if the subset should be random.
		//			bTopSubset- VARIANT_TRUE if the subset should be selected from the start of the
		//				overall set of files, VARIANT_FALSE if it should be selected from the end
		//				of the overall set of files. Ignored when bRandomSubset is VARIANT_TRUE.
		//			bUsePercentage- VARIANT_TRUE if the subset size is a percentage, VARIANT_FALSE
		//				if it is the record count.
		//			nSubsetSize- The size the subset should be (percentage or count per
		//				bUsePercentage).
		//			nOffset- the number of rows to skip before returning the subset.
		//					 if nOffset is >= 0 then a codepath is used which supports 'subselect' queries
		//					 if nOffset is < 0 then the OFFSET...FETCH feature (SQLServer 2012) will not be used.
		// REQUIRES: if nOffset is >= 0
		//			 then bTopSubset == VARIANT_TRUE,
		//				  bRandomSubset == VARIANT_FALSE, and
		//				  bUsePercentage == VARIANT_FALSE
		[id(7), helpstring("method LimitToSubset")] HRESULT LimitToSubset(
			 [in] VARIANT_BOOL bRandomSubset, [in] VARIANT_BOOL bTopSubset,
			 [in] VARIANT_BOOL bUsePercentage, [in] LONG nSubsetSize, [in] LONG nOffset);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Adds a query condition to the current settings.
		// ARGS:	bstrQuery- The query to use as a condition.
		// REQUIRES: bstrQuery must begin with "SELECT FAMFile.ID FROM FAMFile"
		[id(8), helpstring("method AddQueryCondition")] HRESULT AddQueryCondition(
			[in] BSTR bstrQuery);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Adds a file set condition to the current settings.
		// ARGS:	bstrFileSet- The file set.
		[id(9), helpstring("method AddFileSetCondition")] HRESULT AddFileSetCondition(
			[in] BSTR bstrFileSet);
	};

	[
		object,
		uuid(04A14B5A-C96D-44F2-B393-7A6CAA2AECC2),
		dual,
		helpstring("IFAMDBSecureCounter Interface"),
		pointer_default(unique)
	]
	interface IFAMDBSecureCounter : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Initializes the counter of the specified counter ID maintained in the specified pFAMDB.
		[id(1), helpstring("method Initialize")] HRESULT Initialize([in] IFileProcessingDB *pFAMDB,
			[in] long nID, [in] BSTR bstrName, [in] long nAlertLevel, [in] long nAlertMultiple,
			[in] VARIANT_BOOL bIsValid);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets the alert level for this counter.
		[propget, id(2), helpstring("property AlertLevel")] HRESULT AlertLevel([out, retval] long* pnAlertLevel);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: Gets the alert multiple for this counter.
		[propget, id(3), helpstring("property AlertMultiple")] HRESULT AlertMultiple([out, retval] long* pnAlertMultiple);
	}

	//----------------------------------------------------------------------------------------------
	//-C O C L A S S E S ---------------------------------------------------------------------------
	//----------------------------------------------------------------------------------------------
	[
		uuid(FD701438-4C6B-4D6F-B423-1A7AB2D905E0),
		helpstring("FileProcessingManager Class")
	]
	coclass FileProcessingManager
	{
		[default] interface IFileProcessingManager;
		interface IRoleNotifyFAM;
		interface ILicensedComponent;
	};
	[
		uuid(93BEB646-2148-49D9-956C-4FB267D4BD0C),
		helpstring("FileProcessingDB Class")
	]
	coclass FileProcessingDB
	{
		[default] interface IFileProcessingDB;
		interface ILicensedComponent;
	};
	[
		uuid(73C81634-FCDE-4DD8-8ACB-B0C899F38063),
		helpstring("FileSupplierData Class")
	]
	coclass FileSupplierData
	{
		[default] interface IFileSupplierData;
		interface ILicensedComponent;
	};
	[
		uuid(661912F2-1A5F-4B87-8C18-742C0E50C1B1),
		helpstring("ActionStatistics Class")
	]
	coclass ActionStatistics
	{
		[default] interface IActionStatistics;
	};
	[
		uuid(CE2131AD-2D7A-4D17-B4B3-54E9237638B0),
		helpstring("QueueSupplyingRole Class")
	]
	coclass FileSupplyingMgmtRole
	{
		[default] interface IFileSupplyingMgmtRole;
		interface IFileActionMgmtRole;
	};
	[
		uuid(A5870735-FE5D-438a-8632-4F1F59E8C33F),
		helpstring("ProcessingRole Class")
	]
	coclass FileProcessingMgmtRole
	{
		[default] interface IFileProcessingMgmtRole;
		interface IFileActionMgmtRole;
		interface IAccessRequired;
		interface IFileRequestHandler;
	};
	[
		uuid(180CE276-B05E-4557-A6AB-3B5FE29587F5),
		helpstring("FileRecord Class")
	]
	coclass FileRecord
	{
		[default] interface IFileRecord;
	};
	[
		uuid(F6E7D96F-5592-4e13-9E1C-5A16FB07D2E3),
		helpstring("FAMTagManager Class")
	]
	coclass FAMTagManager
	{
		[default] interface IFAMTagManager;
		interface ILicensedComponent;
		interface ITagUtility;
		interface ICopyableObject;
	};
	[
		uuid(A7BD9DDF-04BC-46f3-9965-26E9AEF06091),
		helpstring("FAMDBUtils Class")
	]
	coclass FAMDBUtils
	{
		[default] interface IFAMDBUtils;
	};
	[
		uuid(818A243C-F765-4A43-BF47-A792AAE7261F),
		helpstring("FileProcessingTaskExecutor Class")
	]
	coclass FileProcessingTaskExecutor
	{
		[default] interface IFileProcessingTaskExecutor;
		interface ILicensedComponent;
	};
	[
		uuid(053A3AC5-2CD7-497A-9EB6-CF11E640DDE3)		
	]
	coclass FAMFileSelector
	{
		[default] interface IFAMFileSelector;
		interface ILicensedComponent;
	};
	[
		uuid(B568515C-5F5F-4D3B-A161-C1E35E5866C1)
	]
	coclass WorkItemRecord
	{
		[default] interface IWorkItemRecord;
	};
	[
		uuid(AD638346-ADD9-453D-A9DB-6D620B3B17BD)
	]
	coclass WorkflowDefinition
	{
		[default] interface IWorkflowDefinition;
	};
};
