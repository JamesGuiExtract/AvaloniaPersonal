// AFCore.idl : IDL source for AFCore.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (AFCore.tlb) and marshaling code.

//--------------------------------------------------------------------------------------------------
// NOTES
//--------------------------------------------------------------------------------------------------
// Notes regarding the pProgressStatus argument passed to many interface methods:
// 1.	pProgressStatus method argument: If the caller is interested in receiving progress status,
//			information, a non-NULL pointer value should be passed in for pProgressStatus.
//			CoClasses implementing this interface are free to create sub-progress status
//			objects as they deem appropriate.  Please note that CoClasses are not
//			required to provide progress status information.
//--------------------------------------------------------------------------------------------------

import "oaidl.idl";
import "ocidl.idl";

[
	uuid(69D40760-8162-4822-85D6-C10B02044E9D),
	version(1.0),
	helpstring("UCLID Attribute Finder Engine Core 1.0 Type Library")
]
library UCLID_AFCORELib
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");
	importlib("..\..\..\..\ReusableComponents\COMComponents\UCLIDComponentsLM\COMLM\Code\COMLM.tlb");
	importlib("..\..\..\..\ReusableComponents\COMComponents\UCLIDCOMUtils\Core\Code\UCLIDCOMUtils.tlb");
	importlib("..\..\..\..\ReusableComponents\COMComponents\UCLIDRasterAndOCRMgmt\Core\Code\UCLIDRasterAndOCRMgmt.tlb");
	importlib("..\..\..\..\ReusableComponents\InputFunnel\IFCore\Code\IFCore.tlb");

	/////////////////////////
	// forward declarations
	/////////////////////////
	interface IAttributeSplitter;

	//////////////
	// Enums
	//////////////
	typedef
	[
		uuid(1A825253-D99D-4a55-8866-86367CF5AE8C), 
		helpstring("UCLID EHelpAboutType")
	]
	enum EHelpAboutType
	{
		kUndefinedHelpAbout = 0,
		kFlexIndexHelpAbout = 1,
		kIDShieldHelpAbout = 2,
		kRuleTesterHelpAbout = 3
	} EHelpAboutType;

	typedef
	[
		uuid(699A3C70-B2AE-4F69-AADA-EC01CAD77A55),
		helpstring("Extract ERuleSetRunMode")
	]
	enum ERuleSetRunMode
	{
		kPassInputVOAToOutput = 0,
		kRunPerDocument = 1,
		kRunPerPage = 2
	} ERuleSetRunMode;
			
	typedef
	[
		uuid(DD8C3B29-B4B9-4DD2-B6C9-0A9BA8698DBC),
		helpstring("Extract EParallelRunMode")
	]
	enum
	{
		kUnspecifiedParallelization = 0,
		kNoParallelization = 1,
		kPoliteParallelization = 2,
		kGreedyParallelization = 3
	} EParallelRunMode;

	//////////////
	// Interfaces
	//////////////
	[
		object,
		uuid(F30B389F-1D80-4A43-A3FA-E4B75FDCBC47),
		dual,
		helpstring("IAttribute Interface"),
		pointer_default(unique)
	]
	interface IAttribute : IDispatch
	{
		[propget, id(1), helpstring("property Name")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(1), helpstring("property Name")] HRESULT Name([in] BSTR newVal);
		[propget, id(2), helpstring("property Value")] HRESULT Value([out, retval] ISpatialString **pVal);
		[propput, id(2), helpstring("property Value")] HRESULT Value([in] ISpatialString *newVal);
		[propget, id(3), helpstring("property InputValidator")] HRESULT InputValidator([out, retval] IInputValidator* *pVal);
		[propput, id(3), helpstring("property InputValidator")] HRESULT InputValidator([in] IInputValidator* newVal);
		// pAttributes -- vector of IAttribute
		[propget, id(4), helpstring("property SubAttributes")] HRESULT SubAttributes([out, retval] IIUnknownVector **pAttributes);
		[propput, id(4), helpstring("property SubAttributes")] HRESULT SubAttributes([in] IIUnknownVector *);
		[propget, id(5), helpstring("property AttributeSplitter")] HRESULT AttributeSplitter([out, retval] IAttributeSplitter * *pVal);
		[propput, id(5), helpstring("property AttributeSplitter")] HRESULT AttributeSplitter([in] IAttributeSplitter * newVal);
		[propget, id(6), helpstring("property Type")] HRESULT Type([out, retval] BSTR *pVal);
		[propput, id(6), helpstring("property Type")] HRESULT Type([in] BSTR newVal);
		[id(7), helpstring("method AddType")] HRESULT AddType([in] BSTR newVal);
		[id(8), helpstring("method ContainsType")] HRESULT ContainsType([in] BSTR strType, [out, retval] VARIANT_BOOL *pVal);
		// Will compare text of the Name, Value, Type elements plus the same elements of the sub-attributes.
		// Returns VARIANT_TRUE if the Attributes match, VARIANT_FALSE otherwise
		[id(9), helpstring("method IsNonSpatialMatch")] HRESULT IsNonSpatialMatch([in] IAttribute* pTest, [out, retval] VARIANT_BOOL *pVal);
		// A general data element that can be used by processes that need to associate additional
		// information with an IAttribute instance.
		[propget, id(10), helpstring("property DataObject")] HRESULT DataObject([out, retval] IUnknown **pVal);
		[propput, id(10), helpstring("property DataObject")] HRESULT DataObject([in] IUnknown *newVal);
		// Gets the size of this attribute (1 + sum of size of each subattribute)
		[id(11), helpstring("method GetAttributeSize")]
			HRESULT GetAttributeSize([out, retval] long* plAttributeSize);
		[id(12), helpstring("method SetGUID")] HRESULT SetGUID( const GUID* pGuid );
		// For cases where the DataObjectInstance needs to be cleared for memory management sake, but
		// should be persisted nonetheless, this call will convert the object into a byte string for
		// storage. The DataObject will be set to null, at least until the getter is called.
		// pMiscUtils is not required, but can be provided to prevent unnecessary instantiations of new MiscUtils
		// instances.
		[id(13), helpstring("method StowDataObject")] HRESULT StowDataObject([in] IMiscUtils *pMiscUtils);
	};
	[
		object,
		uuid(27BAF8A9-8078-4366-8236-24DDDDAD93F9),
		dual,
		helpstring("IAFDocument Interface"),
		pointer_default(unique)
	]
	interface IAFDocument : IDispatch
	{
		[propget, id(1), helpstring("property Text")] HRESULT Text([out, retval] ISpatialString* *pVal);
		[propput, id(1), helpstring("property Text")] HRESULT Text([in] ISpatialString* newVal);
		[propget, id(2), helpstring("property StringTags")] HRESULT StringTags([out, retval] IStrToStrMap* *pVal);
		[propput, id(2), helpstring("property StringTags")] HRESULT StringTags([in] IStrToStrMap* newVal);
		[propget, id(3), helpstring("property ObjectTags")] HRESULT ObjectTags([out, retval] IStrToObjectMap* *pVal);
		[propput, id(3), helpstring("property ObjectTags")] HRESULT ObjectTags([in] IStrToObjectMap* newVal);
		[propget, id(4), helpstring("property Attribute")] HRESULT Attribute([out, retval] IAttribute* *pVal);
		[propput, id(4), helpstring("property Attribute")] HRESULT Attribute([in] IAttribute* newVal);
		// Clones all members except clone the sub-attribute hierarchy of Attribute only if bCloneAttributes
		// is VARIANT_TRUE and clone the document Text only if bCloneText is VARIANT_TRUE).
		[id(5), helpstring("method PartialClone")] HRESULT PartialClone([in] VARIANT_BOOL bCloneAttributes,
			[in] VARIANT_BOOL bCloneText, [out, retval] IAFDocument **pAFDoc);
		[id(6), helpstring("method PushRSDFileName")] HRESULT PushRSDFileName([in] BSTR strFileName,
			[out, retval] long *pnStackSize);
		[id(7), helpstring("method PopRSDFileName")] HRESULT PopRSDFileName([out, retval] long *pnStackSize);
		[propget, id(8), helpstring("property RSDFileStack")] HRESULT RSDFileStack([out, retval] IVariantVector* *pVal);
		[propput, id(8), helpstring("property RSDFileStack")] HRESULT RSDFileStack([in] IVariantVector *newVal);
		//-----------------------------------------------------------------------------------------
		// The FKB version to use. The FKB version can only be changed by the top-level rule.
		[propget, id(9), helpstring("property FKBVersion")] HRESULT FKBVersion([out, retval] BSTR *pVal);
		[propput, id(9), helpstring("property FKBVersion")] HRESULT FKBVersion([in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		// An alternate component data root directory to be used in addition to the default
		// component data directory.
		[propget, id(10), helpstring("property AlternateComponentDataDir")] HRESULT AlternateComponentDataDir([out, retval] BSTR *pVal);
		[propput, id(10), helpstring("property AlternateComponentDataDir")] HRESULT AlternateComponentDataDir([in] BSTR newVal);
		[id(11), helpstring("method IsRSDFileExecuting")] HRESULT IsRSDFileExecuting([in] BSTR strFileName, [out, retval] VARIANT_BOOL *pbValue);
		[id(12), helpstring("method GetCurrentRSDFileDir")] HRESULT GetCurrentRSDFileDir([out, retval] BSTR *pstrRSDFileDir);
		[propget, id(13), helpstring("property ParallelRunMode")] HRESULT ParallelRunMode([out, retval] EParallelRunMode *pVal);
		[propput, id(13), helpstring("property ParallelRunMode")] HRESULT ParallelRunMode([in] EParallelRunMode newVal);
	};
	[
		object,
		uuid(3221CE1F-1AE3-40e9-86C4-17B780C30DD2),
		dual,
		helpstring("IAttributeSplitter Interface"),
		pointer_default(unique)
	]
	interface IAttributeSplitter : IDispatch
	{
		//------------------------------------------------------------------------------------------
		// PURPOSE: To split attributes.
		// ARGUMENTS:
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		[id(1), helpstring("method SplitAttribute")] HRESULT SplitAttribute([in] IAttribute* pAttribute, 
			[in] IAFDocument *pAFDoc, [in] IProgressStatus *pProgressStatus);
		//------------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(ACE8CB9F-98C4-41C6-8EFC-4A89EEB5E683),
		dual,
		helpstring("IAttributeFindingRule Interface"),
		pointer_default(unique)
	]
	interface IAttributeFindingRule : IDispatch
	{
		//------------------------------------------------------------------------------------------
		// PURPOSE: To parse the text in the input document and return a vector of found
		//			IAttribute objects.
		// ARGUMENTS:
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		[id(1), helpstring("method ParseText")] HRESULT ParseText([in] IAFDocument* pDocument, 
			[in] IProgressStatus *pProgressStatus, [out, retval] IIUnknownVector** pAttributes);
		//------------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(95A74DE3-67BA-44A7-AC6C-6597BFDA5B68),
		dual,
		helpstring("IValueModifyingRule Interface"),
		pointer_default(unique)
	]
	interface IAttributeModifyingRule : IDispatch
	{
		//------------------------------------------------------------------------------------------
		// PURPOSE:	To modify an attribute value
		// ARGUMENTS:
		//			pAttributeToBeModified - IAttribute expected to be modified by the Value Modifier
		//			pOriginInput - Original input text
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		[id(1), helpstring("method ModifyValue")] HRESULT ModifyValue([in] IAttribute* pAttributeToBeModified, 
			[in] IAFDocument* pOriginInput, [in] IProgressStatus *pProgressStatus);
		//------------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(0E5E90F8-988E-421B-813D-7B206E6F0846),
		dual,
		helpstring("IAttributeRule Interface"),
		pointer_default(unique)
	]
	interface IAttributeRule : IDispatch
	{
		[propget, id(1), helpstring("property Description")] HRESULT Description([out, retval] BSTR *pVal);
		[propput, id(1), helpstring("property Description")] HRESULT Description([in] BSTR newVal);
		[propget, id(2), helpstring("property IsEnabled")] HRESULT IsEnabled([out, retval] VARIANT_BOOL *pVal);
		[propput, id(2), helpstring("property IsEnabled")] HRESULT IsEnabled([in] VARIANT_BOOL newVal);
		[propget, id(3), helpstring("property AttributeFindingRule")] HRESULT AttributeFindingRule([out, retval] IAttributeFindingRule* *pVal);
		[propput, id(3), helpstring("property AttributeFindingRule")] HRESULT AttributeFindingRule([in] IAttributeFindingRule* newVal);
		// pModifyingRuleInfos -- vector of IObjectWithDescription (which has IAttributeModifyingRule with description)
		[propget, id(4), helpstring("property AttributeModifyingRuleInfos")] HRESULT AttributeModifyingRuleInfos([out, retval] IIUnknownVector **pModifyingRuleInfos);
		[propput, id(4), helpstring("property AttributeModifyingRuleInfos")] HRESULT AttributeModifyingRuleInfos([in] IIUnknownVector* pModifyingRuleInfos);
		//------------------------------------------------------------------------------------------
		// PURPOSE:	To execute this AttributeRule on the specified document text and return
		//			the found attributes.
		// ARGUMENTS:
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		//			pFoundAttributes - The returned value containing an IIUnknownVector of
		//				IAttribute objects.
		[id(5), helpstring("method ExecuteRuleOnText")] HRESULT ExecuteRuleOnText([in] IAFDocument* pAFDoc, 
			[in] IProgressStatus *pProgressStatus, [out, retval] IIUnknownVector** pFoundAttributes);
		//------------------------------------------------------------------------------------------
		[propget, id(6), helpstring("property ApplyModifyingRules")] HRESULT ApplyModifyingRules([out, retval] VARIANT_BOOL *pVal);
		[propput, id(6), helpstring("property ApplyModifyingRules")] HRESULT ApplyModifyingRules([in] VARIANT_BOOL newVal);
		// return IDocumentPreprocessor with a description
		[propget, id(7), helpstring("property RuleSpecificDocPreprocessor")] HRESULT RuleSpecificDocPreprocessor([out, retval] IObjectWithDescription **pVal);
		[propput, id(7), helpstring("property RuleSpecificDocPreprocessor")] HRESULT RuleSpecificDocPreprocessor([in] IObjectWithDescription *newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(8), helpstring("property IgnoreErrors")] HRESULT IgnoreErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(8), helpstring("property IgnoreErrors")] HRESULT IgnoreErrors([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(9), helpstring("property IgnorePreprocessorErrors")] HRESULT IgnorePreprocessorErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(9), helpstring("property IgnorePreprocessorErrors")] HRESULT IgnorePreprocessorErrors([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(10), helpstring("property IgnoreModifierErrors")] HRESULT IgnoreModifierErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(10), helpstring("property IgnoreModifierErrors")] HRESULT IgnoreModifierErrors([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// return IOutputHandler with a description
		[propget, id(11), helpstring("property RuleSpecificOutputHandler")] HRESULT RuleSpecificOutputHandler([out, retval] IObjectWithDescription **pVal);
		[propput, id(11), helpstring("property RuleSpecificOutputHandler")] HRESULT RuleSpecificOutputHandler([in] IObjectWithDescription *newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(12), helpstring("property IgnoreOutputHandlerErrors")] HRESULT IgnoreOutputHandlerErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(12), helpstring("property IgnoreOutputHandlerErrors")] HRESULT IgnoreOutputHandlerErrors([in] VARIANT_BOOL newVal);
	};

	[
		object,
		uuid(F574797E-4898-47A1-8498-0501A5454F63),
		dual,
		helpstring("IAttributeFindInfo Interface"),
		pointer_default(unique)
	]
	interface IAttributeFindInfo : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// id(1): R/W Property - IgnoreValues has been removed 10/17/03
		//-----------------------------------------------------------------------------------------
		[propget, id(2), helpstring("property InputValidator")] HRESULT InputValidator(
			[out, retval] IObjectWithDescription* *pVal);
		[propput, id(2), helpstring("property InputValidator")] HRESULT InputValidator(
			[in] IObjectWithDescription *newVal);
		//-----------------------------------------------------------------------------------------
		// IIUnknownVector of IAttributeRule objects
		[propget, id(3), helpstring("property AttributeRules")] HRESULT AttributeRules(
			[out, retval] IIUnknownVector * *pVal);
		[propput, id(3), helpstring("property AttributeRules")] HRESULT AttributeRules(
			[in] IIUnknownVector * newVal);
		//-----------------------------------------------------------------------------------------
		// Boolean property flag indicating whether to stop searching after a value is found.
		[propget, id(4), helpstring("property StopSearchingWhenValueFound")] HRESULT StopSearchingWhenValueFound(
			[out, retval] VARIANT_BOOL *pVal);
		[propput, id(4), helpstring("property StopSearchingWhenValueFound")] HRESULT StopSearchingWhenValueFound(
			[in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To execute the rules on the specified document object and return the
		//			found attributes.
		// ARGUMENTS:
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		//			pAttributes - An IIUnknownVector of IAttribute objects; will be returned by this 
		//				method, and will include a hierarchy of found attributes.
		[id(5), helpstring("method ExecuteRulesOnText")] HRESULT ExecuteRulesOnText(
			[in] IAFDocument* pAFDoc, [in] IProgressStatus *pProgressStatus, 
			[out, retval] IIUnknownVector **pAttributes);
		//-----------------------------------------------------------------------------------------
		// Splitter object property
		[propget, id(6), helpstring("property AttributeSplitter")] HRESULT AttributeSplitter(
			[out, retval] IObjectWithDescription* *pVal);
		[propput, id(6), helpstring("property AttributeSplitter")] HRESULT AttributeSplitter(
			[in] IObjectWithDescription *newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(7), helpstring("property IgnoreAttributeSplitterErrors")] HRESULT
			IgnoreAttributeSplitterErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(7), helpstring("property IgnoreAttributeSplitterErrors")] HRESULT
			IgnoreAttributeSplitterErrors([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(F89D7396-7648-4f11-A553-7375D1DAD73C),
		dual,
		helpstring("IRuleSetUI Interface"),
		pointer_default(unique)
	]
	interface IRuleSetUI : IDispatch
	{
		[id(1), helpstring("method ShowUIForEditing")] HRESULT ShowUIForEditing([in] BSTR strFileName, [in] BSTR strBinFolder);
	}

	[
		object,
		uuid(39754207-0180-4DF6-AC8D-DA95318E0C5B),
		dual,
		helpstring("IRuleTesterUI Interface"),
		pointer_default(unique)
	]
	interface IRuleTesterUI : IDispatch
	{
		[id(1), helpstring("method ShowUI")] HRESULT ShowUI([in] BSTR strFileName);

	};

	[
		object,
		uuid(3877E84A-42DF-451A-8CC8-E230D8CEB630),
		dual,
		helpstring("IRuleSet Interface"),
		pointer_default(unique)
	]
	interface IRuleSet : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PROMISE: If bSetDirtyFlagToTrue == VARIANT_TRUE, the internal dirty flag
		//			is set to True.  If bSetDirtyFlagToTrue == VARIANT_FALSE, then
		//			the default behavior of the dirty flag being set to false
		//			takes effect.
		[id(1), helpstring("method LoadFrom")] HRESULT LoadFrom([in] BSTR strFullFileName, 
			[in] VARIANT_BOOL bSetDirtyFlagToTrue);
		//-----------------------------------------------------------------------------------------
		// PROMISE: If bClearDirty  == VARIANT_TRUE, the internal dirty flag's
		//			value is set to false.  If bClearDirty == VARIANT_FALSE
		//			then the internal dirty flag's value is unchanged.
		// RETURNS: VARIANT_TRUE if the IdentifiableObject GUIDs were regenerated which causes
		//			the member interface pointers to be regenerated. In the case that the caller
		//			has stored these pointers, they should be refreshed.
		[id(2), helpstring("method SaveTo")] HRESULT SaveTo([in] BSTR strFullFileName, 
			[in] VARIANT_BOOL bClearDirty, [out, retval] VARIANT_BOOL* pbGUIDsRegenerated);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	Execute the rules for one or more attributes in this RuleSet on the 
		//			specified AFDocument.
		// ARGUMENTS:
		//			pvecAttributeNames - A IVariantVector containing the names of attributes for
		//				which rules should be executed.  If this pointer is NULL, all rules are
		//				executed.
		//			bstrAlternateComponentDataDir- An alternate component data root directory to be
		//				used in addition to the default component data directory.
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		//			pAttributes - The IIUnknownVector of IAttribute objects returned from this
		//				method will contain the found hierarchy of attributes.
		[id(3), helpstring("method ExecuteRulesOnText")] HRESULT ExecuteRulesOnText(
			[in] IAFDocument* pAFDoc, [in] IVariantVector *pvecAttributeNames, 
			[in] BSTR bstrAlternateComponentDataDir, [in] IProgressStatus *pProgressStatus,
			[out, retval] IIUnknownVector** pAttributes);
		//-----------------------------------------------------------------------------------------
		// The method below has been commented out, but left in the IDL file to remind future
		// developers that id(4) should not be reused for another method or property.
		// [id(4), helpstring("method SetProgressEventHandler")] HRESULT SetProgressEventHandler(
		//	[in] IProgressEventHandler* pEventHandler);
		//-----------------------------------------------------------------------------------------
		[propget, id(5), helpstring("property AttributeNameToInfoMap")] HRESULT 
			AttributeNameToInfoMap([out, retval] IStrToObjectMap * *pVal);
		[propput, id(5), helpstring("property AttributeNameToInfoMap")] HRESULT 
			AttributeNameToInfoMap([in] IStrToObjectMap * newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(6), helpstring("property GlobalDocPreprocessor")] HRESULT 
			GlobalDocPreprocessor([out, retval] IObjectWithDescription **pVal);
		[propput, id(6), helpstring("property GlobalDocPreprocessor")] HRESULT 
			GlobalDocPreprocessor([in] IObjectWithDescription *newVal);
		//-----------------------------------------------------------------------------------------
		// The FileName property is used to retrieve the filename associated with
		// this RuleSet object.  Retrieving the FileName property will return the
		// name of the file from which this object was last loaded, or to which
		// this object was last saved.
		// The FileName put-property is primarily exposed for the sake of 
		// implementing ICopyableObject, but can theoretically be used to overwrite
		// (or disassociate) the filename associated with this object.
		[propget, id(7), helpstring("property FileName")] HRESULT FileName(
			[out, retval] BSTR *pVal);
		[propput, id(7), helpstring("property FileName")] HRESULT FileName(
			[in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(8), helpstring("property IsEncrypted")] HRESULT IsEncrypted(
			[out, retval] VARIANT_BOOL *pVal);
		[propget, id(9), helpstring("property GlobalOutputHandler")] HRESULT GlobalOutputHandler(
			[out, retval] IObjectWithDescription **pVal);
		[propput, id(9), helpstring("property GlobalOutputHandler")] HRESULT GlobalOutputHandler(
			[in] IObjectWithDescription *newVal);
		[propget, id(10), helpstring("property UseDocsIndexingCounter")] HRESULT UseDocsIndexingCounter(
			[out, retval] VARIANT_BOOL *pVal);
		[propput, id(10), helpstring("property UseDocsIndexingCounter")] HRESULT UseDocsIndexingCounter(
			[in] VARIANT_BOOL newVal);
		[propget, id(11), helpstring("property UsePagesRedactionCounter")] HRESULT 
			UsePagesRedactionCounter([out, retval] VARIANT_BOOL *pVal);
		[propput, id(11), helpstring("property UsePagesRedactionCounter")] HRESULT 
			UsePagesRedactionCounter([in] VARIANT_BOOL newVal);
		[propget, id(12), helpstring("property UsePaginationCounter")] HRESULT 
			UsePaginationCounter([out, retval] VARIANT_BOOL *pVal);
		[propput, id(12), helpstring("property UsePaginationCounter")] HRESULT 
			UsePaginationCounter([in] VARIANT_BOOL newVal);
		[propget, id(13), helpstring("property ForInternalUseOnly")] HRESULT 
			ForInternalUseOnly([out, retval] VARIANT_BOOL *pVal);
		[propput, id(13), helpstring("property ForInternalUseOnly")] HRESULT 
			ForInternalUseOnly([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PROMISE:	To return the version number associated with the RuleSet object
		[propget, id(15), helpstring("property VersionNumber")] HRESULT VersionNumber(
			[out, retval] long *nVersion);
		//-----------------------------------------------------------------------------------------
		[propget, id(16), helpstring("property UseDocsRedactionCounter")] HRESULT 
			UseDocsRedactionCounter([out, retval] VARIANT_BOOL *pVal);
		[propput, id(16), helpstring("property UseDocsRedactionCounter")] HRESULT 
			UseDocsRedactionCounter([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(17), helpstring("property IsSwipingRule")] HRESULT IsSwipingRule(
			[out, retval] VARIANT_BOOL *pVal);
		[propput, id(17), helpstring("property IsSwipingRule")] HRESULT IsSwipingRule(
			[in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(18), helpstring("property CanSave")] HRESULT CanSave(
			[out, retval] VARIANT_BOOL *pVal);
		//-----------------------------------------------------------------------------------------
		// The FKB version that should be used for this rule set.
		[propget, id(19), helpstring("property FKBVersion")] HRESULT FKBVersion([out, retval] BSTR *pVal);
		[propput, id(19), helpstring("property FKBVersion")] HRESULT FKBVersion([in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(20), helpstring("property IgnorePreprocessorErrors")] HRESULT
			IgnorePreprocessorErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(20), helpstring("property IgnorePreprocessorErrors")] HRESULT
			IgnorePreprocessorErrors([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		[propget, id(21), helpstring("property IgnoreOutputHandlerErrors")] HRESULT
			IgnoreOutputHandlerErrors([out, retval] VARIANT_BOOL *pVal);
		[propput, id(21), helpstring("property IgnoreOutputHandlerErrors")] HRESULT
			IgnoreOutputHandlerErrors([in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To give the ruleset a chance to perform any cleanup needed at the end of
		// processing
		[id(22), helpstring("method Cleanup")] HRESULT Cleanup();
		//-----------------------------------------------------------------------------------------
		// Ruleset comments visible to customer (to be used in lieu of readme).
		[propget, id(23), helpstring("property Comments")] HRESULT Comments([out, retval] BSTR *pVal);
		[propput, id(23), helpstring("property Comments")] HRESULT Comments([in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		// A vector of RuleExecutionCounters to be decremented when rules are run. If specified,
		// when running a ruleset each counter shall be tried in order until one with the proper
		// counterID is found with enough counts available. If there is no available counter with
		// enough counts (or no RuleExecutionCounters are provided in the first place), a USB key
		// shall be decremented if one is available.
		[propget, id(24), helpstring("property RuleExecutionCounters")] HRESULT RuleExecutionCounters([out, retval] IIUnknownVector **pVal);
		[propput, id(24), helpstring("property RuleExecutionCounters")] HRESULT RuleExecutionCounters([in] IIUnknownVector *pNewVal);
		//-----------------------------------------------------------------------------------------		
		[propget, id(25), helpstring("property UsePagesIndexingCounter")] HRESULT UsePagesIndexingCounter(
			[out, retval] VARIANT_BOOL *pVal);
		[propput, id(25), helpstring("property UsePagesIndexingCounter")] HRESULT UsePagesIndexingCounter(
			[in] VARIANT_BOOL newVal);
		//-----------------------------------------------------------------------------------------		
		[propget, id(26), helpstring("property CustomCounters")] HRESULT CustomCounters(
			[out, retval] IIUnknownVector **pVal);
		[propput, id(26), helpstring("property CustomCounters")] HRESULT CustomCounters(
			[in] IIUnknownVector *pNewVal);
		//-----------------------------------------------------------------------------------------
		// PURPOSE: To flush any accumulated counts to the counters
		[id(27), helpstring("method FlushCounters")] HRESULT FlushCounters();
		//-----------------------------------------------------------------------------------------
		// Run a single attribute finder by name
		// Used by Extract.AttributeFinder.Rules.ParallelRuleSet
		[id(28), helpstring("method RunAttributeFinder")] HRESULT RunAttributeFinder(
			[in] IAFDocument* pAFDoc, BSTR bstrAttributeName, BSTR bstrAlternateComponentDataDir,
			[out, retval] IIUnknownVector** pAttributes);
		//-----------------------------------------------------------------------------------------
		// Get the names of defined attribute (keys of the map of AttributeFindInfos)
		// Used by Extract.AttributeFinder.Rules.ParallelRuleSet
		[propget, id(29), helpstring("property DefinedAttributeNames")] HRESULT DefinedAttributeNames(
			[out, retval] IVariantVector* *pVal);
	};

	[
		object,
		uuid(DA7F55A0-F810-4805-A0D4-791933CDB54E),
		dual,
		helpstring("IRunMode Interface"),
		pointer_default(unique)
	]
	interface IRunMode : IDispatch
	{
		[propget, id(1), helpstring("property RunMode")] HRESULT RunMode([out, retval] ERuleSetRunMode *pRunMode);
		[propput, id(1), helpstring("property RunMode")] HRESULT RunMode([in] ERuleSetRunMode runMode);
		[propget, id(2), helpstring("property InsertAttributesUnderParent")] HRESULT InsertAttributesUnderParent(
			[out, retval] VARIANT_BOOL *pbInsertAttributesUnderParent);
		[propput, id(2), helpstring("property InsertAttributesUnderParent")] HRESULT InsertAttributesUnderParent(
			[in]  VARIANT_BOOL bInsertAttributesUnderParent);
		[propget, id(3), helpstring("property InsertParentName")] HRESULT InsertParentName(
			[out, retval] BSTR *pbstrInsertParentName);
		[propput, id(3), helpstring("property InsertParentName")] HRESULT InsertParentName(
			[in] BSTR bstrInsertParentName);
		[propget, id(4), helpstring("property InsertParentValue")] HRESULT InsertParentValue(
			[out, retval] BSTR *pbstrInsertParentValue);
		[propput, id(4), helpstring("property InsertParentValue")] HRESULT InsertParentValue(
			[in] BSTR bstrInsertParentValue);
		[propget, id(5), helpstring("property DeepCopyInput")] HRESULT DeepCopyInput(
			[out, retval] VARIANT_BOOL *pbDeepCopyInput);
		[propput, id(5), helpstring("property DeepCopyInput")] HRESULT DeepCopyInput(
			[in]  VARIANT_BOOL bDeepCopyInput);	
	}

	[
		object,
		uuid(28A2F3D4-5F34-493C-A62E-332F26FD4A56),
		dual,
		helpstring("IRunModeConfigure Interface"),
		pointer_default(unique)
	]
	interface IRunModeConfigure : IDispatch
	{
		[id(1), helpstring("method ConfigureRunMode")] HRESULT ConfigureRunMode([in] IRunMode *pRunMode, long nHandle);
	}

	[
		object,
		uuid(E7990914-D9FA-4BE0-8B6A-AEBD691CB37F),
		dual,
		helpstring("IRuleTesterAttributeInfo Interface"),
		pointer_default(unique)
	]
	interface IRuleTesterAttributeInfo : IDispatch
	{
		[id(1), helpstring("method RuleTesterAttributeInfo")] HRESULT RuleTesterAttributeInfo(
			[in] IAttribute *pAttribute, ISpatialString *pOriginalOCR, long nHandle);
		[id(2), helpstring("method ShowValueInUSSFileViewer")] HRESULT ShowValueInUSSFileViewer(
			[in] ISpatialString *pValue);
		[id(3), helpstring("method ShowOriginalOCRInUSSFileViewer")] HRESULT ShowOriginalOCRInUSSFileViewer(
			[in] IAttribute *pAttribute, ISpatialString *pOriginalOCR, VARIANT_BOOL bIncludeIntersecting,
			ESpatialEntity entityType);
		[id(4), helpstring("method ShowAttributeHistory")] HRESULT ShowAttributeHistory(
			[in] IAttribute *pAttribute, long nHandle);
	}

	[
		object,
		uuid(8A45E277-0A29-4300-B325-AD674D33ED54),
		dual,
		helpstring("IParallelRuleSet Interface"),
		pointer_default(unique)
	]
	interface IParallelRuleSet : IDispatch
	{
		[id(1), helpstring("method RunAttributeFinders")] HRESULT RunAttributeFinders(
			[in] IIUnknownVector *pDocuments, IRuleSet *pRuleSet, IVariantVector *pAttributeNames,
			BSTR bstrParallelSemaphoreName, IProgressStatus *pProgressStatus,
			[out, retval] IIUnknownVector* *pDocumentAttributes);
	}

	[
		object,
		uuid("3A870A7E-5BE0-4D00-ABD3-8F10B523AF22"),
		dual,
		helpstring("IAnnotationProcessor Interface"),
		pointer_default(unique)
	]
	interface IAnnotationProcessor : IDispatch
	{
		[id(1), helpstring("method ProcessAttribute")] HRESULT ProcessAttribute(
			[in] BSTR fileName, long pageNumber, IAttribute* attribute, BSTR operationType, BSTR definition,
			[out, retval] IAttribute* *updatedAttribute);
	}

	[
		object,
		uuid(28A2337C-2F24-4F0B-ADBC-95FE5E51AB59),
		dual,
		helpstring("IOutputHandler Interface"),
		pointer_default(unique)
	]
	interface IOutputHandler : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To process the output of the rule running process (a IIUnknownVector of
		//			IAttribute objects) in some meaningful way.
		// ARGUMENTS:
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		[id(1), helpstring("method ProcessOutput")] HRESULT ProcessOutput([in] IIUnknownVector* pAttributes, 
			[in] IAFDocument *pDoc, [in] IProgressStatus *pProgressStatus);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(AC7D6CAB-8EC2-43E3-B562-DC03C9FFBBF7),
		dual,
		helpstring("IFAMAwareRuleObject Interface"),
		pointer_default(unique)
	]
	interface IFAMAwareRuleObject : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To modify a IIUnknownVector of IAttribute objects in some way, using the supplied
		//			tag manager to resolve tags.
		[id(1), helpstring("method ProcessAttributes")] HRESULT ProcessAttributes([in] IIUnknownVector* pAttributes, 
			[in] IAFDocument *pDoc, [in] ITagUtility *pTagUtil, [in] IProgressStatus *pProgressStatus);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(FDC8A439-7ABB-421F-AD66-7D9085C6BBF4),
		dual,
		helpstring("IAttributeFinderEngine Interface"),
		pointer_default(unique)
	]
	interface IAttributeFinderEngine : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		//
		// Methods (1 - 5) replaced by generalized FindAttributes() method 06/22/04 - WEL
		//
		//-----------------------------------------------------------------------------------------
		// REQUIRE:	All pointers passed are valid pointers except those
		//			that may be NULL per following comments.
		//			pvecAttributeNames should be NULL if all rules for 
		//			attributes in the ruleset must be executed.
		//			if pvecAttributeNames is not NULL, it must contain valid
		//			strings that are valid attribute names in pRuleSet.
		// PROMISE:	To return an IIUnknownVector of found attributes in accordance
		//			with above comments.  If bShowProgressDlg == VARIANT_TRUE, then
		//			the progress dialog will be displayed while attributes are being
		//			found.  Otherwise, no progress dialog will be displayed.
		// ARGUMENTS:
		//			nNumOfPagesToRecognize - how many pages of the image file to be OCRed.
		//					If -1 is defined, the entire image will be processed
		//					If SrcDoc is not an image file, NumPages is ignored
		//			varRuleSet - this variant argument must either be of BSTR type (in which
		//					case it is expected to be the name of the RSD file name from which
		//					the ruleset is to be loaded), or must be of either IUnknown * type
		//					or IDispatch * type (in which case the object passed in is expected
		//					to also have implemented IRuleSet)
		//			vbUseAFDocText - If VARIANT_TRUE then the SpatialString (pDoc->Text) contained
		//					in the IAFDocument object will be used for running rules (even if it
		//					is blank).  No OCR will be run and even if strSrcDocFileName is a
		//					USS file or text file, it will not be loaded.
		//			bstrAlternateComponentDataDir - An alternate component data root directory to
		//					be used in addition to the default component data directory.
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		[id(6), helpstring("method FindAttributes")] HRESULT FindAttributes(
			[in] IAFDocument *pDoc,
			[in] BSTR strSrcDocFileName,
			[in] long nNumOfPagesToRecognize,
			[in] VARIANT varRuleSet, // see important note about this argument
			[in] IVariantVector* pvecAttributeNames,
			[in] VARIANT_BOOL vbUseAFDocText,
			[in] BSTR bstrAlternateComponentDataDir,
			[in] IProgressStatus *pProgressStatus,
			[out, retval] IIUnknownVector** pAttributes);
		//-----------------------------------------------------------------------------------------
		// Displays a product-specific About box
		[id(8), helpstring("method ShowHelpAboutBox")] HRESULT ShowHelpAboutBox([in] EHelpAboutType eType, [in] BSTR strProductVersion);
		//-----------------------------------------------------------------------------------------
		// Retrieve the full path to the component data folder
		[id(9), helpstring("method GetComponentDataFolder")] HRESULT GetComponentDataFolder([out, retval] BSTR *pbstrComponentDataFolder);
		//-----------------------------------------------------------------------------------------
		// Gets the FKB directory using the supplied FKB version and optional alternate folder to
		// be used in addition to the default or registry specified locations
		[id(10), helpstring("method GetComponentDataFolder2")] HRESULT GetComponentDataFolder2(
			[in] BSTR bstrFKBVersion, [in] BSTR bstrAlternateComponentDataRoot,
			[out, retval] BSTR* pstrComponentDataFolder);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(8A07FC69-4D3E-4a62-8684-C17D35A4C84B),
		dual,
		helpstring("IDocumentPreprocessor Interface"),
		pointer_default(unique)
	]
	interface IDocumentPreprocessor : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	To execute the pre-processing operations on a document.
		// ARGUMENTS:
		//			pProgressStatus - see note # 1 in the "Notes" section at the top of the document.
		[id(1), helpstring("method Process")] HRESULT Process([in] IAFDocument* pDocument,
			[in] IProgressStatus *pProgressStatus);
		//-----------------------------------------------------------------------------------------
	};

	[
		object,
		uuid(A17CD84D-DAD8-444F-B108-3384E6873AAD),
		dual,
		helpstring("IRuleExecutionEnv Interface"),
		pointer_default(unique)
	]
	interface IRuleExecutionEnv : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// Following methods allow push/pop/get access to the RSD file
		// name associated with the currently executing thread.
		// NOTE: we have the stack concept here because RSD files can execute
		// other RSD files which execute other RSD files, etc.
		// PROMISE:	The PushRSDFileName() method will push a filename onto the stack and
		//			the PopRSDFileName() method will pop a filename from the stack.  Both operations
		//			return the size of the stack at the end of the respective operations.
		[id(1), helpstring("method PushRSDFileName")] HRESULT PushRSDFileName([in] BSTR strFileName, [out, retval] long *pnStackSize);
		[id(2), helpstring("method PopRSDFileName")] HRESULT PopRSDFileName([out, retval] long *pnStackSize);
		//-----------------------------------------------------------------------------------------
		[id(3), helpstring("method GetCurrentRSDFileName")] HRESULT GetCurrentRSDFileName([out, retval] BSTR *pstrFileName);
		[id(4), helpstring("method GetCurrentRSDFileDir")] HRESULT GetCurrentRSDFileDir([out, retval] BSTR *pstrRSDFileDir);
		[id(5), helpstring("method IsRSDFileExecuting")] HRESULT IsRSDFileExecuting([in] BSTR strFileName, [out, retval] VARIANT_BOOL *pbValue);
		//-----------------------------------------------------------------------------------------
		// The FKB version to use on the current thread. The FKB version can only be changed by the
		// top-level rule.
		[propget, id(6), helpstring("property FKBVersion")] HRESULT FKBVersion([out, retval] BSTR *pVal);
		[propput, id(6), helpstring("property FKBVersion")] HRESULT FKBVersion([in] BSTR newVal);
		//-----------------------------------------------------------------------------------------
		// An alternate component data root directory to be used in addition to the default
		// component data directory.
		[propget, id(7), helpstring("property AlternateComponentDataDir")] HRESULT AlternateComponentDataDir([out, retval] BSTR *pVal);
		[propput, id(7), helpstring("property AlternateComponentDataDir")] HRESULT AlternateComponentDataDir([in] BSTR newVal);
		[propget, id(8), helpstring("property ShouldAddAttributeHistory")] HRESULT ShouldAddAttributeHistory([out, retval] VARIANT_BOOL * pbVal);
		[propget, id(9), helpstring("property RSDFileBeingEdited")] HRESULT RSDFileBeingEdited([out, retval] BSTR *pVal);
		[propput, id(9), helpstring("property RSDFileBeingEdited")] HRESULT RSDFileBeingEdited([in] BSTR newVal);
		[propget, id(10), helpstring("property EnableParallelProcessing")] HRESULT EnableParallelProcessing([out, retval] VARIANT_BOOL * pbVal);
	};
	
	//---------------------------------------------------------------------------------------------
	// PURPOSE: To guarantee that the Rule Execution Environment's current thread's
	// stack gets pushed ***AND*** popped, no matter whether errors occur
	// during rule execution, etc.
	[
		object,
		uuid(48565161-D0AC-45DC-A534-D34F6181B0A4),
		dual,
		helpstring("IRuleExecutionSession Interface"),
		pointer_default(unique)
	]
	interface IRuleExecutionSession : IDispatch
	{
		//-----------------------------------------------------------------------------------------
		// PURPOSE:	The specified filename will be pushed on to the rule execution environment's
		//			RSD file stack.  And the stack will be popped when the object
		//			implementing this interface is destructed.
		// PROMISE:	To set the RSDfilename associated with the current rule execution session
		//			in the rule execution stack, and to return the size of the rule
		//			execution stack after the specified RSD file has been pushed unto
		//			the stack.
		[id(1), helpstring("method SetRSDFileName")] HRESULT SetRSDFileName([in] BSTR bstrFileName, [out, retval] long *pnStackSize);

		// Applies the FKB version number that should be used for the rule session.
		[id(2), helpstring("method SetFKBVersion")] HRESULT SetFKBVersion([in] BSTR bstrFKBVersion);

		// Applies an alternate component data root directory to be used in addition to the default
		// component data directory.
		[id(3), helpstring("method SetAlternateComponentDataDir")] HRESULT SetAlternateComponentDataDir([in] BSTR bstrAlternateComponentDataDir);
		//-----------------------------------------------------------------------------------------
	};

	//---------------------------------------------------------------------------------------------
	
	[
		object,
		uuid(41BBDD42-760E-4544-A870-F2446DBE9ADB),
		dual,
		helpstring("IDataScorer Interface"),
		pointer_default(unique)
	]
	interface IDataScorer : IDispatch
	{
		// Returns a long value of 0 to 100 as a score for the attribute passed
		//		0    is the worst score
		//		100  is the best score
		[id(1), helpstring("method GetDataScore1")] HRESULT GetDataScore1(
			[in] IAttribute* pAttribute, 
			[in] IAFDocument* pAFDoc, 
			[out, retval] long* pScore );

		// Method will return a long value of 0 to 100 as a score for the attributes passed
		//		0    is the worst score
		//		100  is the best score
		[id(2), helpstring("method GetDataScore2")] HRESULT GetDataScore2(
			[in] IIUnknownVector* pAttributes,
			[in] IAFDocument* pAFDoc, 
			[out, retval] long* pScore );

	};

	//---------------------------------------------------------------------------------------------
	[
		object,
		uuid(975EF59B-82AE-4810-A0F6-820AEE753AB7),
		dual,
		helpstring("IAFCondition Interface"),
		pointer_default(unique)
	]
	interface IAFCondition : IDispatch
	{
		//---------------------------------------------------------------------------------------------
		// REQUIRE: pAFDoc != __nullptr
		// PROMISE: This method will return VARIANT_TRUE if the condition is met
		[id(1), helpstring("method ProcessCondition")] HRESULT ProcessCondition([in] IAFDocument* pAFDoc, [out, retval] VARIANT_BOOL* pbRet);
		//---------------------------------------------------------------------------------------------
	};
	//---------------------------------------------------------------------------------------------
	[
		object,
		uuid(105F98B6-AEF2-417f-B4AB-C1ADA3B050D3),
		dual,
		helpstring("IConditionalRule Interface"),
		pointer_default(unique)
	]
	interface IConditionalRule : IDispatch
	{
		//---------------------------------------------------------------------------------------------
		// PROMISE: Will return the IID of the rule returned by GetRule
		[id(1), helpstring("method GetRuleIID")] HRESULT GetRuleIID([out, retval] IID* pIID);
		//---------------------------------------------------------------------------------------------
		// Note: we use set and get here instead of a property because we 
		// may change this signature to SetCondition(IIUnknown*, IID*)
		// REQUIRE: ppCondition != __nullptr
		// PROMISE: This method will return the conditional object that will be used by this
		//			ConditionalRule to evaluate whether or not to run the rule returned by GetRule
		[id(2), helpstring("method GetCondition")] HRESULT GetCondition([out, retval] IAFCondition** ppCondition);
		// REQUIRE: pCondition != __nullptr
		// PROMISE: This method will set the conditional object that will be used by this
		//			ConditionalRule to evaluate whether or not to run the rule returned by GetRule
		[id(3), helpstring("method SetCondition")] HRESULT SetCondition([in] IAFCondition* pCondition);
		//---------------------------------------------------------------------------------------------
		// REQUIRE: ppRule != __nullptr
		// PROMISE: The rule returned by this method will implement the interface returned by GetRuleIID
		//			or it will be NULL
		[id(4), helpstring("method GetRule")] HRESULT GetRule([out, retval] IUnknown** ppRule);
		// REQUIRE: pRule must implement the interface returned by GetRuleIID 
		//			pRule != __nullptr
		[id(5), helpstring("method SetRule")] HRESULT SetRule([in] IUnknown* pRule);
		//---------------------------------------------------------------------------------------------
		[propget, id(6), helpstring("property InvertCondition")] HRESULT InvertCondition([out, retval] VARIANT_BOOL * pbRetVal);
		[propput, id(6), helpstring("property InvertCondition")] HRESULT InvertCondition([in] VARIANT_BOOL bNewVal);
		//---------------------------------------------------------------------------------------------
		// PROMISE: Will return the name of a com category in which every object implements the IID
		//			returned by GetRuleIID
		//			This name can be used in conjunction with the ICategoryManager Interface in UCLIDComUtils
		[id(7), helpstring("method GetCategoryName")] HRESULT GetCategoryName([out, retval] BSTR *pstrCategoryName);
	};
	[
		object,
		uuid(193C27CE-B571-4B65-B9C6-BDA718FD218C),
		dual,
		helpstring("ISpatiallyCompareAttributes Interface"),
		pointer_default(unique)
	]
	interface ISpatiallyCompareAttributes : IDispatch
	{
	};
	[
		object,
		uuid(EADB307B-0400-4361-ACD7-9DC3F892CF51),
		dual,
		helpstring("IAttributeSelector Interface"),
		pointer_default(unique)
	]
	interface IAttributeSelector : IDispatch
	{
		//---------------------------------------------------------------------------------------------
		// PROMISE: Will return an IUnknownVector with attributes that are selected from the input IUnknownVector
		//			by the implementation of this method
		// ARGUMENTS:
		//			pAttrIn - Attributes eligible to be selected and returned.
		//			pAFDoc - The document context for the selector.
		//			pAttrContext - Parent object's input attributes (or, if the parent object is an
		//						   attribute selector, its context attributes). These attributes
		//						   might not be selectable but could be used to select attributes
		//						   (e.g., with SpatialProximityAS to define reference areas).
		[id(1), helpstring("method SelectAttributes")] HRESULT SelectAttributes( [in] IIUnknownVector *pAttrIn,
			[in] IAFDocument *pAFDoc, [in] IIUnknownVector *pAttrContext, [out, retval] IIUnknownVector **pAttrOut);
	};

	//---------------------------------------------------------------------------------------------
	/////////////////
	// CoClasses
	////////////////
	[
		uuid(8A7249F0-DE76-43D8-8DA1-89B23677985D),
		helpstring("AttributeRule Class")
	]
	coclass AttributeRule
	{
		[default] interface IAttributeRule;
		interface ILicensedComponent;
		interface ICopyableObject;
	};

	[
		uuid(BD457649-B6B8-4B3C-946D-448F3BF5F720),
		helpstring("RuleSet Class")
	]
	coclass RuleSet
	{
		[default] interface IRuleSet;
		interface IRuleSetUI;
		interface IRunMode;
		interface ILicensedComponent;
		interface ICopyableObject;
		interface IHasOCRParameters;
		interface ILoadOCRParameters;
	};
	[
		uuid(28D7B760-37BC-43C6-9627-11E3FD2D73B9),
		helpstring("Attribute Class")
	]
	coclass Attribute
	{
		[default] interface IAttribute;
		interface ILicensedComponent;
		interface ICopyableObject;
		interface IManageableMemory;
		interface IIdentifiableObject;
		interface ICloneIdentifiableObject;
	};
	[
		uuid(BBDE6205-9193-4959-8922-630A9F920ADB),
		helpstring("AFDocument Class")
	]
	coclass AFDocument
	{
		[default] interface IAFDocument;
		interface ILicensedComponent;
		interface ICopyableObject;
		interface IHasOCRParameters;
	};
	[
		uuid(6C9B5C0F-D0AD-477C-82C1-44E2EDDD7C36),
		helpstring("AttributeFinderEngine Class")
	]
	coclass AttributeFinderEngine
	{
		[default] interface IAttributeFinderEngine;
		interface ILicensedComponent;
	};
	[
		uuid(17C3100D-3464-4EC4-A18E-198DDA0E618E),
		helpstring("AttributeFindInfo Class")
	]
	coclass AttributeFindInfo
	{
		[default] interface IAttributeFindInfo;
		interface ILicensedComponent;
		interface ICopyableObject;
	};
	[
		uuid(D0D5A44F-6D66-4708-84D9-8FA682EB9CFB),
		helpstring("RuleExecutionEnv Class")
	]
	coclass RuleExecutionEnv
	{
		[default] interface IRuleExecutionEnv;
	};
	[
		uuid(25763BA4-6151-42F1-A307-1608860D157C),
		helpstring("RuleExecutionSession Class")
	]
	coclass RuleExecutionSession
	{
		[default] interface IRuleExecutionSession;
	};
	[
		uuid(AC714C5E-96DF-4184-8E45-6EA8768037C5),
		helpstring("RuleTesterUI Class")
	]
	coclass RuleTesterUI
	{
		[default] interface IRuleTesterUI;
		interface ILicensedComponent;
	};

	[
		uuid(D8938C93-36E0-4980-AA6D-0296CFBB2B16),
		helpstring("ConditionalRulePP Class")
	]
	coclass ConditionalRulePP
	{
		interface IUnknown;
	};
	[
		uuid(794FB907-9D86-4466-A9A7-DE245C2EA0B6),
		helpstring("SpatiallyCompareAttributes Class")
	]
	coclass SpatiallyCompareAttributes
	{
		[default] interface ISpatiallyCompareAttributes;
		interface ISortCompare;
		interface ILicensedComponent;
	};

	[
        uuid(98E07967-AFEB-4AEB-80F1-263F6429D0E8),
        helpstring("AttributeStorageManager Class")
    ]
    coclass AttributeStorageManager
    {
        [default] interface IStorageManager;
		interface ILicensedComponent;
    };
};
