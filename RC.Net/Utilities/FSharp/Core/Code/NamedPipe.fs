module Extract.Utilities.FSharp.NamedPipe

open Newtonsoft.Json
open System
open System.IO
open System.IO.Pipes
open System.Text
open System.Threading

/// Read a JSON message from a named pipe stream and deserialize it
let readMessage (pipeStream: PipeStream): 'TMessage =
  use response = new MemoryStream()
  let messageBuffer = Array.zeroCreate 1024
  let rec read () =
    let bytesRead = pipeStream.Read (messageBuffer, 0, messageBuffer.Length)
    response.Write(messageBuffer, 0, bytesRead)

    if pipeStream.IsMessageComplete then
      response.Position <- 0L
      use streamReader = new StreamReader(response)
      use jsonReader = new JsonTextReader(streamReader)
      let serializer = JsonSerializer()
      serializer.Deserialize<'a>(jsonReader)
    else
      read()
  read()
(************************************************************************************************************************)

/// Try to read and deserialize a JSON message from a named pipe stream, return None if an exception is thrown
let tryReadMessage (pipeStream: PipeStream): 'TMessage option =
  try readMessage pipeStream |> Some with | _ -> None
(************************************************************************************************************************)

/// Write an object to a named pipe stream as a JSON message
let writeMessage (pipeStream: PipeStream) (message: 'TMessage) =
  let messageBytes =
    message
    |> JsonConvert.SerializeObject
    |> Encoding.UTF8.GetBytes

  pipeStream.Write(messageBytes, 0, messageBytes.Length);
  pipeStream.WaitForPipeDrain();
(************************************************************************************************************************)

type WaitResult = | WaitSuccess | TimedOut | ErroredOut of exn

let private waitForConnection (pipeStream: NamedPipeServerStream) =
  // Wait up to a minute for a connection and then quit
  use timeoutTokenSource = new CancellationTokenSource(TimeSpan.FromMinutes 1.)
  use connectedEvent = new AutoResetEvent(false)
  let mutable waitForConnectionException: Exception = null

  try
    pipeStream.BeginWaitForConnection((fun asyncResult ->
      try
        pipeStream.EndWaitForConnection asyncResult
        connectedEvent.Set() |> ignore
      with
      | e ->
        waitForConnectionException <- e
    ), null) |> ignore

    if WaitHandle.WaitAny([|connectedEvent; timeoutTokenSource.Token.WaitHandle|]) = 1 then
      try
        pipeStream.Dispose()
      with | _ -> ()
      TimedOut
    elif not (isNull waitForConnectionException) then
      try
        pipeStream.Dispose()
      with | _ -> ()
      raise waitForConnectionException
    else
      WaitSuccess
  with | e -> ErroredOut e

/// Create a named pipe stream, listen for messages and send the response generated by the dispatch function
let listenForRequests (pipeName: string) (dispatch: 'TRequest -> 'TResult) =
  // Keep track of whether all tasks have completed or not
  let tasks = System.Collections.Concurrent.ConcurrentDictionary<_,_>()

  // Read a request from the stream on the thread pool and return immediately
  let handleConnection pipeStream =
    async {
      match tryReadMessage pipeStream with
      | Some request ->
        try
          try
            tasks.TryAdd(request, None) |> ignore
            try
              let res = dispatch request
              writeMessage pipeStream (Result.Ok res)
            finally
              tasks.TryRemove request |> ignore
          with | e ->
            try
              let pickledEx = e |> FsPickler.toBytes
              let stringEx = Convert.ToBase64String pickledEx
              writeMessage pipeStream (Result.Error stringEx)
            with | _ -> ()
        finally
          pipeStream.Dispose()
      | None -> ()
    }
    |> Async.Start

  let signalThatPipeHasBeenCreated() =
    match EventWaitHandle.TryOpenExisting("""Local\""" + pipeName) with
    | true, pipeCreatedEvent ->
        pipeCreatedEvent.Set() |> ignore
        Some pipeCreatedEvent
    | _ -> None

  let rec loop () =
    let pipeStream = new NamedPipeServerStream(pipeName, PipeDirection.InOut, -1, PipeTransmissionMode.Message, PipeOptions.Asynchronous);

    let maybePipeCreatedEvent = signalThatPipeHasBeenCreated()

    match waitForConnection pipeStream with
    | WaitSuccess -> handleConnection pipeStream; loop ()
    | TimedOut when not tasks.IsEmpty -> loop () // If tasks are still running then keep waiting
    | TimedOut | ErroredOut _ ->
      // Cleanup the event that lets clients know the pipe has been created before exiting the loop
      match maybePipeCreatedEvent with
      | Some event -> event.Dispose()
      | None -> ()
  loop ()
(************************************************************************************************************************)
