using Extract.Database;
using Extract.Testing.Utilities;
using Moq;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Extract.Utilities.SqlCompactToSqliteConverter.Test
{
    // Tests in this class must be run serially unless [FixtureLifeCycle(LifeCycle.InstancePerTestCase)] is used (upgrade nunit)
    [TestFixture]
    [Category("SqlCompactToSqliteConverter")]
    public class TestDatabaseConverter
    {
        const string _databasePath = @"C:\database.sdf";
        Mock<IDatabaseSchemaManager> _schemaManagerMock;
        Mock<IDatabaseSchemaManagerProvider> _schemaManagerProviderMock;

        [OneTimeSetUp]
        public static void Setup()
        {
            GeneralMethods.TestSetup();
        }

        // Per-test setup
        [SetUp]
        public void Init()
        {
            // Create the mock schema manager, to be setup by individual tests
            _schemaManagerMock = new();

            // Create the mock provider to return the mock manager
            _schemaManagerProviderMock = new();
            _schemaManagerProviderMock
                .Setup(x => x.GetSqlCompactSchemaManager(It.IsAny<string>()))
                .Returns(_schemaManagerMock.Object);
        }

        /// UpdateSqlCompactSchema should call IDatabaseSchemaManagerProvider.GetSqlCompactSchemaManager
        [Test]
        [Category("Automated")]
        public async Task UpdateSqlCompactSchema_ShouldCallGetSqlCompactSchemaManager()
        {
            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);

            await converter.UpdateSqlCompactSchema(_databasePath);

            _schemaManagerProviderMock.Verify(x => x.GetSqlCompactSchemaManager(_databasePath), Times.Once);
        }

        /// UpdateSqlCompactSchema should call IDatabaseSchemaManager.IsUpdateRequired
        [Test]
        [Category("Automated")]
        public async Task UpdateSqlCompactSchema_ShouldCallIsUpdateRequired()
        {
            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);

            await converter.UpdateSqlCompactSchema(_databasePath);

            _schemaManagerMock.Verify(x => x.IsUpdateRequired, Times.Once);
        }

        /// UpdateSqlCompactSchema should call IDatabaseSchemaManager.BeginUpdateToLatestSchema when IsUpdateRequired is true
        [Test]
        [Category("Automated")]
        public async Task UpdateSqlCompactSchema_ShouldCallBeginUpdateToLatestSchema()
        {
            _schemaManagerMock.Setup(x => x.IsUpdateRequired).Returns(true);

            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);

            await converter.UpdateSqlCompactSchema(_databasePath);

            _schemaManagerMock.Verify(x => x.BeginUpdateToLatestSchema(null, It.IsAny<CancellationTokenSource>()), Times.Once);
        }

        /// UpdateSqlCompactSchema should not call IDatabaseSchemaManager.BeginUpdateToLatestSchema when IsUpdateRequired is false
        [Test]
        [Category("Automated")]
        public async Task UpdateSqlCompactSchema_ShouldNotCallBeginUpdateToLatestSchema()
        {
            _schemaManagerMock.Setup(x => x.IsUpdateRequired).Returns(false);

            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);

            await converter.UpdateSqlCompactSchema(_databasePath);

            _schemaManagerMock.Verify(x => x.BeginUpdateToLatestSchema(null, It.IsAny<CancellationTokenSource>()), Times.Never);
        }

        // Reduced script generated by SqlCeScripting/DatabaseConverter, modified to contain a tricky, multi-line value
        static readonly string[] _scriptLines = new[]
        {
            "-- User Table information:"
            ,"-- Number of tables: 1"
            ,"-- Unit: 6 row(s)"
            ,""
            ,"SELECT 1;"
            ,"PRAGMA foreign_keys=OFF;"
            ,"BEGIN TRANSACTION;"
            ,"CREATE TABLE [Unit] ("
            ,"  [Unit] nvarchar(50) NOT NULL COLLATE NOCASE"
            ,", [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL"
            ,");"
            ,"INSERT INTO [Unit] ([Unit],[ID]) VALUES ("
            ,"'mg/mg Cr',1352);"
            ,"INSERT INTO [Unit] ([Unit],[ID]) VALUES ("
            ,"'p);"
            ,"f',1353);"
            ,"INSERT INTO [Unit] ([Unit],[ID]) VALUES ("
            ,"'EU/mL',1354);"
            ,"INSERT INTO [Unit] ([Unit],[ID]) VALUES ("
            ,"'10*6',1355);"
            ,"INSERT INTO [Unit] ([Unit],[ID]) VALUES ("
            ,"'bil/L',1356);"
            ,"INSERT INTO [Unit] ([Unit],[ID]) VALUES ("
            ,"'tril/L',1357);"
            ,"CREATE INDEX [Unit_idxUnit] ON [Unit] ([Unit] ASC);"
            ,"COMMIT;"
            ,""
        };

        /// Test basic functionality of script dividing hack
        [Test]
        [Category("Automated")]
        public void BreakupSqliteScript_ShouldDivideBeforeInputStatements()
        {
            List<string> commands = DatabaseConverter.BreakupSqliteScript(_scriptLines).ToList();

            Assert.AreEqual(7, commands.Count);
            Assert.AreEqual(5, commands.Where(IsInsertCommand).Count());

            static bool IsInsertCommand(string command)
            {
                return command.StartsWith("INSERT INTO", StringComparison.Ordinal)
                    && command.EndsWith(");", StringComparison.Ordinal);
            }
        }

        /// Test that a false positive case is avoided
        [Test]
        [Category("Automated")]
        public void BreakupSqliteScript_ShouldPreserveMultilineValues()
        {
            List<string> commands = DatabaseConverter.BreakupSqliteScript(_scriptLines).ToList();

            CollectionAssert.Contains(commands, "INSERT INTO [Unit] ([Unit],[ID]) VALUES (\r\n'p);\r\nf',1353);");
        }

        /// Test that no commands are lost
        [Test]
        [Category("Automated")]
        public void BreakupSqliteScript_ShouldPreserveAllMeaningfulText()
        {
            List<string> commands = DatabaseConverter.BreakupSqliteScript(_scriptLines).ToList();

            Assert.AreEqual(
                string.Join(Environment.NewLine, _scriptLines).TrimEnd(),
                string.Join(Environment.NewLine, commands));
        }

        /// Test that relative output paths are not allowed
        [Test]
        [Category("Automated")]
        public void ConvertRequiresFullOutputPath()
        {
            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);
            var exn = Assert.ThrowsAsync<ExtractException>(async delegate
            {
                await converter.Convert(@"C:\input.sdf", "output.sdf");
            });

            StringAssert.Contains("outputPath cannot be a relative path", exn.Message);
        }


        /// Run full conversion and verify correct results
        [TestCase(false, false, TestName = "Convert with no schema manager")]
        [TestCase(true, false, TestName = "Convert with schema manager but no update required")]
        [TestCase(true, true, TestName = "Convert with schema update required")]
        public void ConvertShouldConvertDatabase(bool hasSchemaManager, bool isSchemaUpdateRequired)
        {
            var expectedSettings =
                Enumerable.Range(1, 10)
                .Select(i => new KeyValuePair<string, string>($"Setting{i:D2}", $"Value{i:D2}"))
                .ToList();

            using TemporaryFile sqlCompactDatabaseFile = new(".sdf", false);
            File.Delete(sqlCompactDatabaseFile.FileName);

            CreateSqlCompactDatabaseWithData(sqlCompactDatabaseFile.FileName, expectedSettings);

            using TemporaryFile sqliteDatabaseFile = new(".sqlite", false);
            using TemporaryFile backupFile = new(".sdf", false);

            if (!hasSchemaManager)
            {
                // Setup to not have a schema manager
                _schemaManagerProviderMock
                    .Setup(x => x.GetSqlCompactSchemaManager(It.IsAny<string>()))
                    .Returns<IDatabaseSchemaManager>(null);
            }
            else if (isSchemaUpdateRequired)
            {
                // Setup to require a schema update and return the path to a temp file
                FileAssert.Exists(backupFile.FileName);
                _schemaManagerMock.Setup(x => x.IsUpdateRequired).Returns(true);
                _schemaManagerMock.Setup(x => x.BeginUpdateToLatestSchema(null, It.IsAny<CancellationTokenSource>()))
                    .ReturnsAsync(backupFile.FileName);
            }
            else
            {
                // Setup to not require a schema update
                _schemaManagerMock.Setup(x => x.IsUpdateRequired).Returns(false);
            }

            string statusMessage = "";
            void UpdateStatusMessage(string message) { statusMessage += message; }

            // Run the conversion
            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);

            // Force the result here rather than awaiting it so that test failures will be less confusing
            converter.Convert(sqlCompactDatabaseFile.FileName, sqliteDatabaseFile.FileName, UpdateStatusMessage)
                .GetAwaiter()
                .GetResult();

            if (!hasSchemaManager)
            {
                // Verify that the status message indicates that there is no schema manager
                StringAssert.Contains("Checking for schema updates... No schema manager found.", statusMessage);
            }
            else if (isSchemaUpdateRequired)
            {
                // Verify that the status message indicates that a schema update took place
                StringAssert.Contains("Checking for schema updates... Updated schema.", statusMessage);

                // Verify that the backup database has been deleted (real schema managers will have created this
                // along side the input database, which for the SqlCompactToSqliteConverter will be in a temp dir)
                FileAssert.DoesNotExist(backupFile.FileName);
            }
            else
            {
                // Verify that the status message indicates that no schema update took place
                StringAssert.Contains("Checking for schema updates... No updates required.", statusMessage);
            }

            // Verify that the output database exists and has the correct content
            var actualSettings = GetSettings(sqliteDatabaseFile.FileName);
            CollectionAssert.AreEqual(expectedSettings, actualSettings);
        }

        /// Test that a very large database is converted correctly
        /// https://extract.atlassian.net/browse/ISSUE-17747
        [Test]
        [Category("Automated")]
        public void ConvertLargeDatabase()
        {
            var expectedSettings =
                Enumerable.Range(1, 50_000)
                .Select(i => new KeyValuePair<string, string>($"Setting{i:D5}", $"{i:D5}_{new String('X', 249)}"))
                .ToList();

            using TemporaryFile sqlCompactDatabaseFile = new(".sdf", false);
            File.Delete(sqlCompactDatabaseFile.FileName);

            CreateSqlCompactDatabaseWithData(sqlCompactDatabaseFile.FileName, expectedSettings);

            using TemporaryFile sqliteDatabaseFile = new(".sqlite", false);
            using TemporaryFile backupFile = new(".sdf", false);

            // Setup to not have a schema manager
            _schemaManagerProviderMock
                .Setup(x => x.GetSqlCompactSchemaManager(It.IsAny<string>()))
                .Returns<IDatabaseSchemaManager>(null);

            string statusMessage = "";
            void UpdateStatusMessage(string message) { statusMessage += message; }

            // Run the conversion
            DatabaseConverter converter = new(_schemaManagerProviderMock.Object);

            // Force the result here rather than awaiting it so that test failures will be less confusing
            converter.Convert(sqlCompactDatabaseFile.FileName, sqliteDatabaseFile.FileName, UpdateStatusMessage)
                .GetAwaiter()
                .GetResult();

            // Verify that multiple script files were used
            Assert.That(Regex.IsMatch(statusMessage, @"Sent script to output file\(s\)(.*\.sql\b){2}"));

            // Verify that the output database exists and has the correct content
            var actualSettings = GetSettings(sqliteDatabaseFile.FileName);
            CollectionAssert.AreEqual(expectedSettings, actualSettings);
        }

        /// Test the split-concatenated files logic for single file case
        [Test]
        [Category("Automated")]
        public void SplitConcatenatedPaths_WorksForSingleFileNoCommas()
        {
            string baseName = @"C:\tmp\filename.sql";
            string concatenatedPaths = baseName;
            string[] expectedFiles = new[] { baseName };

            string[] actualFiles = DatabaseConverter.SplitConcatenatedPaths(baseName, concatenatedPaths);

            CollectionAssert.AreEqual(expectedFiles, actualFiles);
        }

        /// Test the split-concatenated files logic for single file with comma in path
        [Test]
        [Category("Automated")]
        public void SplitConcatenatedPaths_WorksForSingleFileWithComma()
        {
            string baseName = @"C:\heyer, nat\tmp\filename.sql";
            string concatenatedPaths = baseName;
            string[] expectedFiles = new[] { baseName };

            string[] actualFiles = DatabaseConverter.SplitConcatenatedPaths(baseName, concatenatedPaths);

            CollectionAssert.AreEqual(expectedFiles, actualFiles);
        }

        /// Test the split-concatenated files logic for multiple files
        [Test]
        [Category("Automated")]
        public void SplitConcatenatedPaths_WorksForMultipleFiles()
        {
            string baseName = @"C:\heyer, nat\tmp\filename.sql";
            string[] expectedFiles = new[] { @"C:\heyer, nat\tmp\filename_0001.sql", @"C:\heyer, nat\tmp\filename_0002.sql", @"C:\heyer, nat\tmp\filename_0003.sql" };
            string concatenatedPaths = String.Join(", ", expectedFiles);

            string[] actualFiles = DatabaseConverter.SplitConcatenatedPaths(baseName, concatenatedPaths);

            CollectionAssert.AreEqual(expectedFiles, actualFiles);
        }

        // Create a sql compact DB with data in a settings table
        private static void CreateSqlCompactDatabaseWithData(string databaseFile, IEnumerable<KeyValuePair<string, string>> data)
        {
            using SqlCompactDatabaseWithSettingsTable database = new(databaseFile);
            database.CreateDatabase();
            database.Settings.InsertAllOnSubmit(data.Select(kv => new Settings { Name = kv.Key, Value = kv.Value }));
            database.SubmitChanges();
        }

        // Query a sqlite DB for data in a settings table
        private static List<KeyValuePair<string, string>> GetSettings(string sqliteDatabaseFile)
        {
            using SqliteDatabaseWithSettingsTable database = new(sqliteDatabaseFile);
            return database.Settings
                .Select(setting => new KeyValuePair<string, string>(setting.Name, setting.Value))
                .ToList();
        }
    }
}